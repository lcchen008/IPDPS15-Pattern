!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
0	input/Session.vim	/^normal! 0$/;"	m
026l	Session.vim	/^normal! 026l$/;"	m
02l	lib/Session.vim	/^normal! 02l$/;"	m
<Plug>NetrwBrowseX	Session.vim	/^nnoremap <silent> <Plug>NetrwBrowseX :call netrw#NetrwBrowseX(expand("<cWORD>"),0)$/;"	m
<Plug>NetrwBrowseX	input/Session.vim	/^nnoremap <silent> <Plug>NetrwBrowseX :call netrw#NetrwBrowseX(expand("<cWORD>"),0)$/;"	m
<Plug>NetrwBrowseX	lib/Session.vim	/^nnoremap <silent> <Plug>NetrwBrowseX :call netrw#NetrwBrowseX(expand("<cWORD>"),0)$/;"	m
ALIGN_SIZE	regular/parameters.h	19;"	d
Adjust_EdgeList	misc.c	/^void Adjust_EdgeList (int n_nodes, int n_edges, int (*el)[2], int *ind, int *ind2)$/;"	f
Adjust_PartnerList	misc.c	/^void Adjust_PartnerList (int n_nodes, int n_ptnrs, int *ptnr, int *from, int *ind, int *ind2)  $/;"	f
Allocate	irregular/partition_cuda.cu	/^void partition_cuda::Allocate()$/;"	f	class:partition_cuda
Allocate	lib/buffer.cpp	/^void Buffer::Allocate(int num_dims, int elm_size, IndexArray size)$/;"	f	class:Buffer
AuxTmr1	metis.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
AuxTmr2	metis.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
AuxTmr3	metis.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
AuxTmr4	metis.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
AuxTmr5	metis.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
AuxTmr6	metis.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
BFSearch	misc.c	/^BFSearch(int n_nodes, int n_ptnrs, int *ptnr, int *from, int *ind) $/;"	f
BFSearch0	misc.c	/^BFSearch0(int n_nodes, int n_ptnrs, int (*el)[2], int *ind) $/;"	f
BORDER	lib/common.h	20;"	d
BOXSIZ	input/gen.c	7;"	d	file:
BOXSIZE	moldyn.h	56;"	d
BOXSIZE	moldyn.h	59;"	d
BOXSIZE	moldyn.h	62;"	d
BOXSIZE	moldyn.h	65;"	d
BOXSIZE	moldyn.h	68;"	d
BOXSIZE	moldyn.h	71;"	d
BOXSIZE	moldyn.h	74;"	d
BSIZE	kmeans.h	6;"	d
Buffer	lib/buffer.cpp	/^Buffer::Buffer(BufferDeleter deleter):size_(0), buf_(NULL), deleter_(deleter)$/;"	f	class:Buffer
Buffer	lib/buffer.h	/^class Buffer$/;"	c
BufferCUDADev	lib/buffer_cuda.cu	/^BufferCUDADev::BufferCUDADev()$/;"	f	class:BufferCUDADev
BufferCUDADev	lib/buffer_cuda.h	/^class BufferCUDADev:public Buffer $/;"	c
BufferCUDAHost	lib/buffer_cuda.cu	/^BufferCUDAHost::BufferCUDAHost() $/;"	f	class:BufferCUDAHost
BufferCUDAHost	lib/buffer_cuda.h	/^class BufferCUDAHost: public Buffer $/;"	c
BufferDeleter	lib/buffer.h	/^	typedef void (*BufferDeleter) (void *); 	$/;"	t	class:Buffer
BufferHost	lib/buffer.cpp	/^BufferHost::BufferHost(): Buffer(free)$/;"	f	class:BufferHost
BufferHost	lib/buffer.h	/^class BufferHost:public Buffer$/;"	c
CACHE_LINE	input/misc.h	149;"	d
CACHE_LINE	misc.h	149;"	d
CACHE_LINE_SZ	misc.c	18;"	d	file:
CC	Makefile	/^CC=gcc$/;"	m
CC	input/Makefile	/^CC     = gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS=$(OPT) -O3 -I . -I .\/lib -std=c++0x$/;"	m
CFLAGS	input/Makefile	/^CFLAGS = -O4 -DBUILD_LIST -DCOORD -DBLOCK_ADAPTIVE -DTIME -DCSTYLE -I..$/;"	m
CHECK_CUDA	lib/cu_util.h	7;"	d
CHECK_MPI	lib/macro.h	60;"	d
CO	regular/roc.h	/^typedef struct roc CO;$/;"	t	typeref:struct:roc
CONFLICT	moldyn.cu	86;"	d	file:
CPACK_OPT	misc.c	2567;"	d	file:
CPU	lib/macro.h	78;"	d
CPU_BLOCK_SIZE	irregular/parameters.h	7;"	d
CPU_BLOCK_SIZE	regular/parameters.h	10;"	d
CPU_KERNEL	irregular/cpu_kernel.cu	3;"	d	file:
CPU_KERNEL	irregular/roc.cu	3;"	d	file:
CPU_KERNEL	lib/compute_cpu.cpp	2;"	d	file:
CPU_KERNEL	regular/cpu_kernel.cu	2;"	d	file:
CPU_KERNEL	regular/roc.cu	1;"	d	file:
CPU_KERNEL_TOOLS	irregular/cpu_kernel_tools.h	2;"	d
CPU_NUM_PARTS	irregular/parameters.h	14;"	d
CPU_ONLY	lib/common.h	4;"	d
CPU_PREALLOC_SIZE	regular/parameters.h	9;"	d
CPU_THREADS	lib/common.h	12;"	d
CPU_THREADS	regular/parameters.h	25;"	d
CPU_TILE_SIZE	lib/common.h	16;"	d
CPU_X	irregular/parameters.h	10;"	d
CPU_Y	irregular/parameters.h	11;"	d
CPU_Z	irregular/parameters.h	12;"	d
CPack	misc.c	/^CPack(int n_nodes, int n_ptnrs, int *ptnr, int *from, int *ind)$/;"	f
CPack0	misc.c	/^CPack0(int n_nodes, int n_ptnrs, int (*el)[2], int *ind)$/;"	f
CSTYLE	misc.c	20;"	d	file:
CType	metis.h	/^  int CType;			\/* The type of coarsening *\/$/;"	m	struct:controldef
CUDA_CHECK_ERROR	lib/macro.h	17;"	d
CUDA_DEVICE_INIT	lib/macro.h	30;"	d
CUDA_SAFE_CALL	lib/macro.h	8;"	d
CUTOFF	moldyn.h	83;"	d
CXX	Makefile	/^CXX=mpicxx$/;"	m
CalcHaloSize	lib/grid_mpi.cu	/^size_t GridMPI::CalcHaloSize(int dim, unsigned width) $/;"	f	class:GridMPI
Cargs	lib/cpu_util.h	/^typedef struct cargs Cargs;$/;"	t	typeref:struct:cargs
CoarsenTmr	metis.h	/^  timer TotalTmr, InitPartTmr, MatchTmr, ContractTmr, CoarsenTmr, UncoarsenTmr, $/;"	m	struct:controldef
CoarsenTo	metis.h	/^  int CoarsenTo;		\/* The # of vertices in the coarsest graph *\/$/;"	m	struct:controldef
Cobject	irregular/roc.h	/^typedef struct Reduction_Object_C Cobject;$/;"	t	typeref:struct:Reduction_Object_C
ContractTmr	metis.h	/^  timer TotalTmr, InitPartTmr, MatchTmr, ContractTmr, CoarsenTmr, UncoarsenTmr, $/;"	m	struct:controldef
Convert2Edgelist	misc.c	/^Convert2Edgelist(int n_nodes, int n_edges, int (*lr)[2], int *partners, int *from) $/;"	f
Convert2FPartner	misc.c	/^Convert2FPartner(int n_nodes, int n_edges, int (*lr)[2], int *fpartners, int *ffrom) $/;"	f
Convert2Partner	misc.c	/^Convert2Partner(int n_nodes, int n_edges, int (*lr)[2], int *partners, int *from) $/;"	f
CopyContinuousSubgrid	lib/data_util.cpp	/^static void CopyContinuousSubgrid($/;"	f	file:
CopyContinuousSubgrid	lib/grid_util.cc	/^static void CopyContinuousSubgrid($/;"	f	file:
CopySubgrid	lib/data_util.cpp	/^static void CopySubgrid(void *buf, const void *src,$/;"	f	file:
CopySubgrid	lib/grid_util.cc	/^static void CopySubgrid(void *buf, const void *src,$/;"	f	file:
Copyin	lib/grid_mpi.cu	/^void GridMPI::Copyin(const void *src)$/;"	f	class:GridMPI
CopyinHalo	lib/grid_mpi.cu	/^void GridMPI::CopyinHalo(int dim, unsigned width, bool fw)$/;"	f	class:GridMPI
CopyinSubgrid	lib/data_util.cpp	/^void CopyinSubgrid(size_t elm_size, int num_dims,$/;"	f
CopyinSubgrid	lib/grid_util.cc	/^void CopyinSubgrid(size_t elm_size, int num_dims,$/;"	f
Copyout	lib/grid_mpi.cu	/^void GridMPI::Copyout(void *dst)$/;"	f	class:GridMPI
CopyoutHalo	lib/grid_mpi.cu	/^void GridMPI::CopyoutHalo(int dim, unsigned width, bool fw)$/;"	f	class:GridMPI
CopyoutSubgrid	lib/data_util.cpp	/^void CopyoutSubgrid(size_t elm_size, int num_dims,$/;"	f
CopyoutSubgrid	lib/grid_util.cc	/^void CopyoutSubgrid(size_t elm_size, int num_dims,$/;"	f
CpuArgs	irregular/cpu_args.h	/^typedef struct cpu_args CpuArgs;$/;"	t	typeref:struct:cpu_args
Create	lib/grid.h	/^	static Grid* Create(int unit_size, int num_dims, const IndexArray &size)$/;"	f	class:Grid
Create	lib/grid_cpu.cpp	/^GridCPU *GridCPU::Create($/;"	f	class:GridCPU
Create	lib/grid_cuda.cu	/^GridCuda *GridCuda::Create(int unit_size,$/;"	f	class:GridCuda
Create	lib/grid_mpi.cu	/^GridMPI *GridMPI::Create($/;"	f	class:GridMPI
CreateGrid	lib/grid_view.cpp	/^GridMPI *Grid_view::CreateGrid(int unit_size, int num_dims, $/;"	f	class:Grid_view
CreateGrid	lib/grid_view_cpu.cpp	/^GridCPU *Grid_view_cpu::CreateGrid(int elm_size, int num_dims, const IndexArray &my_offset, const IndexArray &my_size, const int halo_width, int num_devices, int device_id)$/;"	f	class:Grid_view_cpu
CreateGrid	lib/grid_view_cuda.cu	/^GridCuda* Grid_view_cuda::CreateGrid(int elm_size, int num_dims, const IndexArray &my_offset, const IndexArray &my_size, const int halo_width, int num_devices, int device_id)$/;"	f	class:Grid_view_cuda
CreatePartition	irregular/partition_view.cpp	/^partition_mpi *partition_view::CreatePartition()$/;"	f	class:partition_view
CreateRuntime	lib/stencil_creator.h	/^	StencilRuntime *CreateRuntime()$/;"	f	class:StencilCreator
CtrlType	metis.h	/^typedef struct controldef CtrlType;$/;"	t	typeref:struct:controldef
DEFAULT_TIMESTEP	moldyn.h	84;"	d
DENSITY	input/gen.c	10;"	d	file:
DENSITY	moldyn.h	81;"	d
DEVICE	irregular.h	10;"	d
DEVICE	irregular/hash.h	6;"	d
DEVICE	regular.h	11;"	d
DEVICE	regular/hash.h	7;"	d
DEVICE	regular/kernel_tools.h	4;"	d
DEVICE	stencil.h	8;"	d
DIMENSION	misc.c	/^int  DIMENSION =	3;	\/* used in RCB routies *\/$/;"	v
DIMS	main.cpp	14;"	d	file:
DIMS	main2.cpp	9;"	d	file:
DIMSIZE	moldyn.h	88;"	d
DIST_LIMIT	misc.c	2414;"	d	file:
DRAND	moldyn.h	18;"	d
DeleteBuffers	lib/grid.cpp	/^void Grid::DeleteBuffers()$/;"	f	class:Grid
DeleteBuffers	lib/grid_cpu.cpp	/^void GridCPU::DeleteBuffers()$/;"	f	class:GridCPU
DeleteBuffers	lib/grid_cuda.cu	/^void GridCuda::DeleteBuffers()$/;"	f	class:GridCuda
DeleteBuffers	lib/grid_mpi.cu	/^void GridMPI::DeleteBuffers()$/;"	f	class:GridMPI
DeleteChunk	lib/buffer_cuda.cu	/^void BufferCUDADev::DeleteChunk(void *ptr) $/;"	f	class:BufferCUDADev
DeleteChunk	lib/buffer_cuda.cu	/^void BufferCUDAHost::DeleteChunk(void *ptr) $/;"	f	class:BufferCUDAHost
DeleteHaloBuffers	lib/grid_cuda.cu	/^void GridCuda::DeleteHaloBuffers()$/;"	f	class:GridCuda
DeleteHaloBuffers	lib/grid_mpi.cu	/^void GridMPI::DeleteHaloBuffers()$/;"	f	class:GridMPI
DeviceBuf	lib/buffer_cuda.h	/^	void *DeviceBuf(){return buf_d_;};$/;"	f	class:BufferCUDAHost
DoWork	regular/roc.cu	/^    bool DoWork = true;$/;"	l
DoWork	regular/rog.cu	/^	bool DoWork = true;$/;"	l
DoWork	regular/ros.cu	/^	bool DoWork = true;$/;"	l
EDGE	irregular/data_type.h	/^typedef struct edge EDGE;$/;"	t	typeref:struct:edge
EDegreeType	metis.h	/^typedef struct edegreedef EDegreeType;$/;"	t	typeref:struct:edegreedef
EI	misc.c	38;"	d	file:
EMPTY_BUCKET_VALUE	irregular/parameters.h	30;"	d
EQ_LIMIT	misc.c	1390;"	d	file:
EXTERN	moldyn.cu	32;"	d	file:
EXTRA	misc.c	34;"	d	file:
ExchangeBoundaries	lib/grid_view.cpp	/^void Grid_view::ExchangeBoundaries(GridMPI *g,$/;"	f	class:Grid_view
ExchangeBoundaries	lib/grid_view.cpp	/^void Grid_view::ExchangeBoundaries(GridMPI *grid,$/;"	f	class:Grid_view
ExchangeBoundariesAsync	lib/grid_view.cpp	/^void Grid_view::ExchangeBoundariesAsync(GridMPI *grid, $/;"	f	class:Grid_view
Expand2FPartner	misc.c	/^Expand2FPartner(int n_nodes, int n_edges, int *partners, int *from, int *fpartners, int *ffrom) $/;"	f
FCPU	irregular/cpu_kernel_tools.h	/^namespace FCPU$/;"	n
FFGPU	regular.h	/^namespace FFGPU{$/;"	n
FFGPU	regular/hash.h	/^namespace FFGPU{$/;"	n
FFGPU	regular/kernel_tools.h	/^namespace FFGPU{$/;"	n
FFGPU	regular/rog.cu	/^using namespace FFGPU;$/;"	v
FGPU	irregular.h	/^namespace FGPU$/;"	n
FGPU	irregular/hash.h	/^namespace FGPU{$/;"	n
FGPU	stencil.h	/^namespace FGPU{$/;"	n
FOREACH	lib/array.h	/^    FOREACH (it, this->begin(), this->begin() + len) {$/;"	f
FOREACH	lib/array.h	/^    FOREACH(i, this->begin(), this->end()) {$/;"	f
FOREACH	lib/array.h	/^  FOREACH (i, x.begin(), x.end()) { sj << *i; }$/;"	f
FOREACH	lib/data_util.cpp	/^  	FOREACH (oit, offsets->begin(), offsets->end()) $/;"	f
FOREACH	lib/data_util.cpp	/^    		FOREACH (oit, offsets->begin(), offsets->end()) $/;"	f
FOREACH	lib/grid_util.cc	/^    FOREACH (oit, offsets->begin(), offsets->end()) {$/;"	f
FOREACH	lib/grid_util.cc	/^  FOREACH (oit, offsets->begin(), offsets->end()) {$/;"	f
FOREACH	lib/grid_view.cpp	/^  	FOREACH (it, requests.begin(), requests.end()) $/;"	f
FOREACH	lib/macro.h	38;"	d
FREE	input/misc.h	30;"	d
FREE	input/misc.h	48;"	d
FREE	misc.h	30;"	d
FREE	misc.h	48;"	d
FREE2	input/misc.h	32;"	d
FREE2	input/misc.h	49;"	d
FREE2	misc.h	32;"	d
FREE2	misc.h	49;"	d
FREE3	input/misc.h	34;"	d
FREE3	input/misc.h	50;"	d
FREE3	misc.h	34;"	d
FREE3	misc.h	50;"	d
FREE_NOW	input/misc.h	37;"	d
FREE_NOW	misc.h	37;"	d
Free	lib/buffer.cpp	/^void Buffer::Free()$/;"	f	class:Buffer
FreeGraph	metis.h	248;"	d
GET_FLOAT2	lib/macro.h	73;"	d
GET_FLOAT3	lib/macro.h	69;"	d
GET_INT2	lib/macro.h	75;"	d
GET_INT3	lib/macro.h	71;"	d
GLOBAL_POOL_SIZE	regular/parameters.h	13;"	d
GO	regular/rog.h	/^typedef struct Reduction_Object_GPU GO;$/;"	t	typeref:struct:Reduction_Object_GPU
GPART_OPT	misc.c	2565;"	d	file:
GPU	lib/macro.h	79;"	d
GPU_BLOCKS	lib/common.h	13;"	d
GPU_BLOCKS	regular/parameters.h	28;"	d
GPU_BLOCK_SIZE	irregular/parameters.h	8;"	d
GPU_BLOCK_SIZE	regular/parameters.h	8;"	d
GPU_KERNEL	irregular/gpu_kernel.cu	5;"	d	file:
GPU_KERNEL	irregular/rog.cu	1;"	d	file:
GPU_KERNEL	irregular/ros.cu	1;"	d	file:
GPU_KERNEL	lib/compute_cuda.cu	2;"	d	file:
GPU_KERNEL	regular/gpu_kernel.cu	5;"	d	file:
GPU_KERNEL	regular/rog.cu	1;"	d	file:
GPU_KERNEL	regular/ros.cu	6;"	d	file:
GPU_KERNELH	irregular/gpu_kernel.h	2;"	d
GPU_KERNEL_TOOLS	irregular/gpu_kernel_tools.cu	2;"	d	file:
GPU_KERNEL_TOOLS	regular/gpu_kernel_tools.cu	2;"	d	file:
GPU_PREALLOC_SIZE	regular/parameters.h	7;"	d
GPU_THREADS	lib/common.h	14;"	d
GPU_THREADS	regular/parameters.h	27;"	d
GPU_TILE_SIZE	lib/common.h	17;"	d
GPU_TILE_SIZE	lib/stencil_runtime.cu	/^		tiling(num_dims(), internal_size, internal_start, GPU_TILE_SIZE, internal_tiles[j + 1]);$/;"	l
GPU_X	irregular/parameters.h	16;"	d
GPU_Y	irregular/parameters.h	17;"	d
GRIDSZ	km.cu	7;"	d	file:
GROUP	misc.c	2415;"	d	file:
GTE_LIMIT	misc.c	1389;"	d	file:
GT_LIMIT	misc.c	1388;"	d	file:
G_KERNEL	irregular/gpu_kernel.cu	2;"	d	file:
G_KERNEL	regular/gpu_kernel.cu	2;"	d	file:
G_PartPartition	misc.c	/^G_PartPartition(int n_nodes, int n_ptnrs, int *ptnr, int *from, int *ind)$/;"	f
G_PartPartition0	misc.c	/^G_PartPartition0(int n_nodes, int n_ptnrs, int (*el)[2], int *ind)$/;"	f
Get	lib/buffer.h	/^	const void *Get() const {return buf_;}$/;"	f	class:Buffer
Get	lib/buffer.h	/^	void *Get() {return buf_;}$/;"	f	class:Buffer
GetChunk	lib/buffer.cpp	/^void *BufferHost::GetChunk(IndexArray &size)$/;"	f	class:BufferHost
GetChunk	lib/buffer_cuda.cu	/^void *BufferCUDADev::GetChunk(IndexArray &size) $/;"	f	class:BufferCUDADev
GetChunk	lib/buffer_cuda.cu	/^void *BufferCUDAHost::GetChunk(IndexArray &size) $/;"	f	class:BufferCUDAHost
GetGPUNumber	lib/cu_util.cu	/^int GetGPUNumber()$/;"	f
GetHaloPeerBuf	lib/grid_view.cpp	/^char *GridMPI::GetHaloPeerBuf(int dim, bool fw, unsigned width) $/;"	f	class:GridMPI
GetLinearSize	lib/data_util.cpp	/^size_t GetLinearSize(int num_dims, size_t elm_size, const IndexArray &s)$/;"	f
GetLocalBufferRealSize	lib/grid_mpi.h	/^  	size_t GetLocalBufferRealSize() const $/;"	f	class:GridMPI
GetLocalBufferSize	lib/grid_mpi.h	/^	size_t GetLocalBufferSize()$/;"	f	class:GridMPI
GetProcessRank	lib/grid_view.cpp	/^int Grid_view::GetProcessRank(const IndexArray &proc_index) const $/;"	f	class:Grid_view
Gobject	irregular/rog.h	/^typedef struct Reduction_Object_G Gobject;$/;"	t	typeref:struct:Reduction_Object_G
GraphType	metis.h	/^typedef struct graphdef GraphType;$/;"	t	typeref:struct:graphdef
GreaterThan	lib/array.h	/^  bool GreaterThan(const IntegerArray<ty> &x, int num_dims) {$/;"	f	class:IntegerArray
Grid	lib/grid.cpp	/^Grid::Grid(int unit_size, int num_dims, const IndexArray &size):$/;"	f	class:Grid
Grid	lib/grid.h	/^	Grid(){}$/;"	f	class:Grid
Grid	lib/grid.h	/^class Grid$/;"	c
GridCPU	lib/grid_cpu.cpp	/^GridCPU::GridCPU(int unit_size, int num_dims,$/;"	f	class:GridCPU
GridCPU	lib/grid_cpu.h	/^class GridCPU:public GridMPI$/;"	c
GridCalcOffset3D	lib/data_util.h	/^inline _OFFSET_TYPE GridCalcOffset3D(PSIndex x, PSIndex y, PSIndex z,$/;"	f
GridCalcOffset3D	lib/data_util.h	/^inline intptr_t GridCalcOffset3D(const IndexArray &index,$/;"	f
GridCalcOffset3D	lib/grid_util.h	/^inline _OFFSET_TYPE GridCalcOffset3D(PSIndex x, PSIndex y, PSIndex z, $/;"	f
GridCalcOffset3D	lib/grid_util.h	/^inline intptr_t GridCalcOffset3D(const IndexArray &index,$/;"	f
GridCuda	lib/grid_cuda.cu	/^GridCuda::GridCuda(int unit_size, $/;"	f	class:GridCuda
GridCuda	lib/grid_cuda.h	/^class GridCuda: public GridMPI$/;"	c
GridMPI	lib/grid_mpi.cu	/^GridMPI::GridMPI(int unit_size, int num_dims,$/;"	f	class:GridMPI
GridMPI	lib/grid_mpi.h	/^	GridMPI(){}$/;"	f	class:GridMPI
GridMPI	lib/grid_mpi.h	/^class GridMPI: public Grid$/;"	c
Grid_view	lib/grid_view.cpp	/^Grid_view::Grid_view(int num_dims, IndexArray &global_size, int proc_num_dims, $/;"	f	class:Grid_view
Grid_view	lib/grid_view.h	/^	Grid_view(){}$/;"	f	class:Grid_view
Grid_view	lib/grid_view.h	/^class Grid_view $/;"	c
Grid_view_cpu	lib/grid_view_cpu.h	/^class Grid_view_cpu:public Grid_view$/;"	c
Grid_view_cuda	lib/grid_view_cuda.h	/^class Grid_view_cuda:public Grid_view$/;"	c
HASH	irregular/hash.h	2;"	d
HASH	regular/hash.h	2;"	d
HasHalo	lib/grid_mpi.h	/^  	bool HasHalo() const { return ! (halo_.fw == 0 && halo_.bw == 0); }  $/;"	f	class:GridMPI
IDXTYPE_INT	metis.h	3;"	d
INCLUDE_RUNTIME_H_	include/runtime.h	2;"	d
INTERNAL	lib/common.h	19;"	d
IRIndex	lib/common.h	/^typedef int64_t IRIndex;$/;"	t
IRREGULAR_CPU_ARGS_H_	irregular/cpu_args.h	2;"	d
IRREGULAR_CPU_KERNEL_H_	irregular/cpu_kernel.h	2;"	d
IRREGULAR_DATA_TYPE_H_	irregular/data_type.h	2;"	d
IRREGULAR_H_	irregular.h	2;"	d
IRREGULAR_IRREGULAR_RUNTIME_H_	irregular/irregular_runtime.h	2;"	d
IRREGULAR_PARAMETERS_H_	irregular/parameters.h	2;"	d
IRREGULAR_PARTITION_CPU_H_	irregular/partition_cpu.h	2;"	d
IRREGULAR_PARTITION_CUDA_H_	irregular/partition_cuda.h	2;"	d
IRREGULAR_PARTITION_H_	irregular/partition.h	2;"	d
IRREGULAR_PARTITION_MPI_H_	irregular/partition_mpi.h	2;"	d
IRREGULAR_PARTITION_UTIL_H_	irregular/partition_util.h	2;"	d
IRREGULAR_PARTITION_VIEW_H_	irregular/partition_view.h	2;"	d
IRREGULAR_REDUCTION_ARRAY_H_	irregular/reduction_array.h	2;"	d
IRREGULAR_REORDER_H_	irregular/reorder.h	2;"	d
IType	metis.h	/^  int IType;			\/* The type of initial partitioning *\/$/;"	m	struct:controldef
IndexArray	lib/array.h	/^typedef IntegerArray<int> IndexArray;$/;"	t
InitBuffer	lib/grid.cpp	/^void Grid::InitBuffer()$/;"	f	class:Grid
InitBuffer	lib/grid_cpu.cpp	/^void GridCPU::InitBuffer()$/;"	f	class:GridCPU
InitBuffer	lib/grid_cuda.cu	/^void GridCuda::InitBuffer()$/;"	f	class:GridCuda
InitBuffer	lib/grid_mpi.cu	/^void GridMPI::InitBuffer() $/;"	f	class:GridMPI
InitCoordinates	input/gen.c	/^void InitCoordinates()$/;"	f
InitCoordinates	moldyn.cu	/^void InitCoordinates()$/;"	f
InitForces	moldyn.cu	/^void  InitForces()$/;"	f
InitGraph	metis.h	247;"	d
InitHaloBuffers	lib/grid_cuda.cu	/^void GridCuda::InitHaloBuffers()$/;"	f	class:GridCuda
InitHaloBuffers	lib/grid_mpi.cu	/^void GridMPI::InitHaloBuffers()$/;"	f	class:GridMPI
InitPartTmr	metis.h	/^  timer TotalTmr, InitPartTmr, MatchTmr, ContractTmr, CoarsenTmr, UncoarsenTmr, $/;"	m	struct:controldef
InitSettings	moldyn.cu	/^void InitSettings()$/;"	f
InitVelocities	moldyn.cu	/^void  InitVelocities()$/;"	f
IntArray	lib/array.h	/^typedef IntegerArray<int> IntArray;$/;"	t
IntVector	lib/array.h	/^typedef std::vector<int> IntVector;$/;"	t
IntegerArray	lib/array.h	/^  IntegerArray() {$/;"	f	class:IntegerArray
IntegerArray	lib/array.h	/^  IntegerArray(const IntegerArray<ty2> &v) {$/;"	f	class:IntegerArray
IntegerArray	lib/array.h	/^  IntegerArray(const ty2 *v) {$/;"	f	class:IntegerArray
IntegerArray	lib/array.h	/^  explicit IntegerArray(ty x) {$/;"	f	class:IntegerArray
IntegerArray	lib/array.h	/^  explicit IntegerArray(ty x, ty y) {$/;"	f	class:IntegerArray
IntegerArray	lib/array.h	/^  explicit IntegerArray(ty x, ty y, ty z) {$/;"	f	class:IntegerArray
IntegerArray	lib/array.h	/^class IntegerArray: public boost::array<ty, MAX_DIM> {$/;"	c
IrregularBarrier	irregular/irregular_runtime.cu	/^void IrregularRuntime::IrregularBarrier()$/;"	f	class:IrregularRuntime
IrregularInit	irregular/irregular_runtime.cu	/^void IrregularRuntime::IrregularInit()$/;"	f	class:IrregularRuntime
IrregularInit	irregular/partition_runtime.cu	/^void IrregularRuntime::IrregularInit(int argc, char *argv[])$/;"	f	class:IrregularRuntime
IrregularRuntime	irregular/irregular_runtime.cu	/^IrregularRuntime::IrregularRuntime(IRIndex num_edges, $/;"	f	class:IrregularRuntime
IrregularRuntime	irregular/irregular_runtime.h	/^class IrregularRuntime$/;"	c
IrregularRuntime	irregular/partition_runtime.cu	/^IrregularRuntime::IrregularRuntime(IRIndex num_edges, $/;"	f	class:IrregularRuntime
IrregularStart	irregular/irregular_runtime.cu	/^void IrregularRuntime::IrregularStart()$/;"	f	class:IrregularRuntime
K	kmeans.h	5;"	d
KERNEL_TOOLS	regular/kernel_tools.h	2;"	d
KEY	irregular/parameters.h	/^typedef int KEY;$/;"	t
KMEANS	kmeans.h	2;"	d
KMEANS_DIM	kmeans.h	4;"	d
KeyValueType	metis.h	/^struct KeyValueType {$/;"	s
KeyValueType	metis.h	/^typedef struct KeyValueType KeyValueType;$/;"	t	typeref:struct:KeyValueType
L1_CACHE	misc.c	17;"	d	file:
L1_cache	misc.c	/^    int L1_cache, part_sz; $/;"	l
LDFLAGS	Makefile	/^LDFLAGS=$(OPT) -lpthread -I . -I .\/lib$/;"	m
LEVEL_arg	misc.c	/^int LEVEL_arg = 12;$/;"	v
LEVEL_arg	moldyn.cu	/^          npart_arg <<= LEVEL_arg;$/;"	l
LIBS	Makefile	/^LIBS = -lm$/;"	m
LIBS	input/Makefile	/^LIBS   = -lm $/;"	m
LIB_ARRAY_H_	lib/array.h	2;"	d
LIB_BUFFER_CUDA_H_	lib/buffer_cuda.h	2;"	d
LIB_BUFFER_H_	lib/buffer.h	2;"	d
LIB_COMMON_H_	lib/common.h	2;"	d
LIB_COMPUTE_CPU_H_	lib/compute_cpu.h	2;"	d
LIB_CPU_UTIL_H_	lib/cpu_util.h	2;"	d
LIB_CU_DS_H	lib/CU_DS.h	2;"	d
LIB_CU_UTILS_H_	lib/cu_util.h	2;"	d
LIB_DATA_UTIL_H_	lib/data_util.h	2;"	d
LIB_DS_H_	lib/DS.h	2;"	d
LIB_EXCHANGE_H_	lib/exchange.h	2;"	d
LIB_GRID_CPU_H_	lib/grid_cpu.h	2;"	d
LIB_GRID_CUDA_H_	lib/grid_cuda.h	2;"	d
LIB_GRID_H	lib/grid.h	2;"	d
LIB_GRID_MPI_H_	lib/grid_mpi.h	2;"	d
LIB_GRID_UTIL_H_	lib/grid_util.h	2;"	d
LIB_GRID_VIEW_CPU_H_	lib/grid_view_cpu.h	2;"	d
LIB_GRID_VIEW_CUDA_H_	lib/grid_view_cuda.h	2;"	d
LIB_MACRO_H_	lib/macro.h	2;"	d
LIB_MPI_UTIL_H_	lib/mpi_util.h	2;"	d
LIB_PARTITIONER_H_	lib/grid_view.h	2;"	d
LIB_RUNTIME_H_	lib/stencil_runtime.h	2;"	d
LIB_TEST_TEST_UTIL_H_	lib/test/test_util.h	2;"	d
LIB_TIME_UTIL_	lib/time_util.h	2;"	d
LIB_UTIL_H_	lib/util.h	2;"	d
LOCAL	misc.c	271;"	d	file:
LOGGING_FILE_BASENAME	lib/util.h	47;"	d
LOG_DEBUG	lib/util.h	52;"	d
LOG_DEBUG	lib/util.h	57;"	d
LR_AdaptiveCostModel	misc.c	/^LR_AdaptiveCostModel(double b, double Ov, double m, double t)$/;"	f
LR_AdaptiveDecided	misc.c	/^static int LR_AdaptiveDecided = 0; \/* turn on after costmodel *\/$/;"	v	file:
LR_AdaptiveDecision	misc.c	/^LR_AdaptiveDecision()$/;"	f
LR_Ov	misc.c	/^static double LR_b, LR_Ov, LR_m, LR_t;$/;"	v	file:
LR_ac_time	misc.c	/^static double LR_ac_time = 0.0;$/;"	v	file:
LR_access_change_begin	misc.c	/^LR_access_change_begin()$/;"	f
LR_access_changed	misc.c	/^LR_access_changed()$/;"	f
LR_adaptive	misc.c	/^static int LR_adaptive = 0;	   \/* set from customer code *\/$/;"	v	file:
LR_apply	misc.c	/^static int LR_apply;$/;"	v	file:
LR_apply_cnt	misc.c	/^int LR_apply_cnt = 0;$/;"	v
LR_apply_next_change	misc.c	/^static int LR_apply_next_change = 0;$/;"	v	file:
LR_b	misc.c	/^static double LR_b, LR_Ov, LR_m, LR_t;$/;"	v	file:
LR_count	misc.c	/^static int LR_count = 0; 	   \/* initialized to 0 *\/$/;"	v	file:
LR_index	misc.c	/^int **LR_index = NULL;$/;"	v
LR_is_periodic	misc.c	/^static int LR_is_periodic = 0;$/;"	v	file:
LR_iter_cnt	misc.c	/^static int LR_iter_cnt = 0;$/;"	v	file:
LR_last	misc.c	/^    static int LR_last = 0;$/;"	l	file:
LR_last_iter	misc.c	/^static int LR_last_iter = 0;$/;"	v	file:
LR_last_lap	misc.c	/^static int LR_last_lap;$/;"	v	file:
LR_last_opt_freq	misc.c	/^static double LR_last_opt_freq;$/;"	v	file:
LR_m	misc.c	/^static double LR_b, LR_Ov, LR_m, LR_t;$/;"	v	file:
LR_n_iter	misc.c	/^static int LR_n_iter;$/;"	v	file:
LR_opt_called	misc.c	/^static int LR_opt_called = 0;      \/* consider last two sampling iterations *\/$/;"	v	file:
LR_opt_called_since_GPART	misc.c	/^static int LR_opt_called_since_GPART;$/;"	v	file:
LR_opt_freq	misc.c	/^static double LR_opt_freq;$/;"	v	file:
LR_orig_sample	misc.c	/^static int LR_orig_sample;$/;"	v	file:
LR_overriden	misc.c	/^static int LR_overriden = 0;       \/* turn when users set LR_opt_freq *\/$/;"	v	file:
LR_ovrhd	misc.c	/^static double LR_ovrhd[10];$/;"	v	file:
LR_param_override	misc.c	/^int LR_param_override = 0;$/;"	v
LR_param_set	misc.c	/^static int LR_param_set = 0; $/;"	v	file:
LR_reorder_map	misc.c	/^LR_reorder_map(int **idx)$/;"	f
LR_sample	misc.c	/^static int LR_sample[10] = {NO_OPT,NO_OPT,RCB_OPT,GPART_OPT,RBFS_OPT,NO_OPT};$/;"	v	file:
LR_sampling_iter	misc.c	/^static int LR_sampling_iter;$/;"	v	file:
LR_set_adaptive	misc.c	/^LR_set_adaptive(int n_iter, int adapt_freq)$/;"	f
LR_set_choice	misc.c	/^LR_set_choice(int optimization)$/;"	f
LR_set_coordinate	misc.c	/^LR_set_coordinate(double (*xyz)[3])$/;"	f
LR_set_override_adaptive	misc.c	/^LR_set_override_adaptive(int opt_freq) $/;"	f
LR_set_parameters	misc.c	/^LR_set_parameters(int n_nodes, int n_edges, int unit_sz)$/;"	f
LR_t	misc.c	/^static double LR_b, LR_Ov, LR_m, LR_t;$/;"	v	file:
LR_times	misc.c	/^static double LR_times[10];$/;"	v	file:
LTE_LIMIT	misc.c	1387;"	d	file:
LessThan	lib/array.h	/^  bool LessThan(const IntegerArray<ty> &x, int num_dims) {$/;"	f	class:IntegerArray
ListNodeType	metis.h	/^struct ListNodeType {$/;"	s
ListNodeType	metis.h	/^typedef struct ListNodeType ListNodeType;$/;"	t	typeref:struct:ListNodeType
LocalityReordering	misc.c	/^LocalityReordering (int num, ...)$/;"	f
LocalityReordering2	misc.c	/^LocalityReordering2 (int num, ...)$/;"	f
Ltile	lib/CU_DS.h	/^typedef struct linear_tile Ltile;$/;"	t	typeref:struct:linear_tile
MALLOC	input/misc.h	21;"	d
MALLOC	input/misc.h	41;"	d
MALLOC	misc.h	21;"	d
MALLOC	misc.h	41;"	d
MALLOC2	input/misc.h	24;"	d
MALLOC2	input/misc.h	43;"	d
MALLOC2	misc.h	24;"	d
MALLOC2	misc.h	43;"	d
MALLOC3	input/misc.h	27;"	d
MALLOC3	input/misc.h	45;"	d
MALLOC3	misc.h	27;"	d
MALLOC3	misc.h	45;"	d
MAXBUF	misc.c	54;"	d	file:
MAXIDX	metis.h	12;"	d
MAXINTERACT	input/gen.c	9;"	d	file:
MAXINTERACT	moldyn.h	57;"	d
MAXINTERACT	moldyn.h	60;"	d
MAXINTERACT	moldyn.h	63;"	d
MAXINTERACT	moldyn.h	66;"	d
MAXINTERACT	moldyn.h	69;"	d
MAXINTERACT	moldyn.h	72;"	d
MAXINTERACT	moldyn.h	75;"	d
MAXLINE	misc.c	33;"	d	file:
MAXNCON	metis.h	230;"	d
MAX_DIM	lib/common.h	8;"	d
MAX_PASS	misc.c	31;"	d	file:
MAX_STATS	moldyn.h	172;"	d
MAX_TIMERS	moldyn.h	151;"	d
MERGE	misc.c	1366;"	d	file:
MERGE2	misc.c	1376;"	d	file:
METIS_OPT	misc.c	2564;"	d	file:
MIN	moldyn.h	89;"	d
MISC	input/Makefile	/^MISC   = ..\/misc$/;"	m
MISC_H	input/misc.h	2;"	d
MISC_H	misc.h	2;"	d
MOLDYN_H	moldyn.h	2;"	d
MPI_HOME	Makefile	/^MPI_HOME=\/usr\/local\/mvapich2\/1.7-intel$/;"	m
MatchTmr	metis.h	/^  timer TotalTmr, InitPartTmr, MatchTmr, ContractTmr, CoarsenTmr, UncoarsenTmr, $/;"	m	struct:controldef
MetisPartition	misc.c	/^MetisPartition(int n_nodes, int n_ptnrs, int *ptnr, int *from, int *ind)$/;"	f
MetisPartition0	misc.c	/^MetisPartition0(int n_nodes, int n_ptnrs, int (*el)[2], int *ind)$/;"	f
N	main.cpp	15;"	d	file:
N	main2.cpp	10;"	d	file:
NA_LocalityReordering	misc.c	/^NA_LocalityReordering (int num, ...)$/;"	f
NA_LocalityReordering2	misc.c	/^NA_LocalityReordering2 (int num, ...)$/;"	f
NI	misc.c	37;"	d	file:
NO_OPT	misc.c	2562;"	d	file:
NPROC	main.cpp	16;"	d	file:
NPROC	main2.cpp	11;"	d	file:
NPROC	moldyn.cu	52;"	d	file:
NRInfoType	metis.h	/^typedef struct nrinfodef NRInfoType;$/;"	t	typeref:struct:nrinfodef
NTIMESTEP	moldyn.h	78;"	d
NUM_BUCKETS_G	irregular/parameters.h	5;"	d
NUM_BUCKETS_G	regular/parameters.h	5;"	d
NUM_BUCKETS_S	irregular/parameters.h	4;"	d
NUM_BUCKETS_S	regular/parameters.h	4;"	d
NUM_EDGES	moldyn.h	20;"	d
NUM_GROUPS	regular/parameters.h	17;"	d
NUM_PARTICLES	input/gen.c	8;"	d	file:
NUM_PARTICLES	moldyn.h	80;"	d
NUM_POINTS	moldyn.h	21;"	d
NUM_PROCS	km.cu	4;"	d	file:
NVCC	Makefile	/^NVCC=\/usr\/local\/cuda\/4.2.9\/bin\/nvcc$/;"	m
NVFLAGS	Makefile	/^NVFLAGS=$(OPT) -O3 -arch=sm_20 -lpthread -I . -I$(MPI_HOME)\/include\/  -L$(MPI_HOME)\/lib$/;"	m
N_REPOSITION	input/misc.h	132;"	d
N_REPOSITION	misc.h	132;"	d
Nearest	misc.c	/^Nearest (int iteration, double freq)$/;"	f
Nearest0	misc.c	/^Nearest0 (int iteration, double freq)$/;"	f
NodeBlocking	misc.c	/^NodeBlocking (double (*xyz)[3], int n_nodes, double side, int *n_xyz)$/;"	f
OBJS	Makefile	/^OBJS=km.o \\$/;"	m
OPT	Makefile	/^OPT=$/;"	m
ORIG_ADAPTIVE	moldyn.h	51;"	d
Offset	regular/data_type.h	/^typedef struct element_t Offset;$/;"	t	typeref:struct:element_t
PARTITION	irregular/partitioner.h	2;"	d
POSTPONE_FREE	input/misc.h	36;"	d
POSTPONE_FREE	misc.h	36;"	d
POW	moldyn.h	16;"	d
PQueueType	metis.h	/^struct PQueueType {$/;"	s
PQueueType	metis.h	/^typedef struct PQueueType PQueueType;$/;"	t	typeref:struct:PQueueType
PROG	input/Makefile	/^PROG   = gen$/;"	m
PSIndex	lib/common.h	/^typedef int64_t PSIndex;$/;"	t
PS_XDELETE	lib/macro.h	49;"	d
PS_XDELETEA	lib/macro.h	54;"	d
PS_XFREE	lib/macro.h	43;"	d
Part	irregular/data_type.h	/^typedef struct part Part;$/;"	t	typeref:struct:part
Partitioner	irregular/partitioner.cpp	/^Partitioner::Partitioner(int *part_index, int num_points, IRIndex num_edges, int num_devices, double *speeds, int reduction_elm_size, int node_num_dims, int rank)$/;"	f	class:Partitioner
Partitioner	irregular/partitioner.h	/^class Partitioner$/;"	c
PrintResults	moldyn.cu	/^void PrintResults(int move, double ekin, double vel, double count)$/;"	f
ProjectTmr	metis.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
PureRcbPartition	misc.c	/^PureRcbPartition(int n_nodes, double xyz[][3], int *ind)$/;"	f
RBFS_OPT	misc.c	2566;"	d	file:
RCB_OPT	misc.c	2563;"	d	file:
REDUCTION	regular.h	3;"	d
REDUCTION_C	irregular/roc.h	2;"	d
REDUCTION_G	irregular/rog.h	2;"	d
REDUCTION_S	irregular/ros.h	2;"	d
REGULAR_CPU_KERNEL_H_	regular/cpu_kernel.h	2;"	d
REGULAR_DATA_MPI_H_	regular/data_partition_mpi.h	2;"	d
REGULAR_DATA_TYPE_H_	regular/data_type.h	2;"	d
REGULAR_GPU_ARG_H_	regular/args.h	2;"	d
REGULAR_PARAMETERS_H_	regular/parameters.h	2;"	d
REGULAR_RUNTIME_H_	regular/regular_runtime.h	2;"	d
REGULAR_SPLITTER_H_	regular/splitter.h	3;"	d
REPOSITION	input/misc.h	55;"	d
REPOSITION	misc.h	55;"	d
REPOSITION2	input/misc.h	93;"	d
REPOSITION2	misc.h	93;"	d
RInfoType	metis.h	/^typedef struct rinfodef RInfoType;$/;"	t	typeref:struct:rinfodef
ROC	irregular/roc.cu	2;"	d	file:
ROC	regular/roc.h	2;"	d
ROG	irregular/rog.cu	3;"	d	file:
ROG	regular/rog.cu	4;"	d	file:
ROGH	regular/rog.h	2;"	d
ROOT	misc.c	1340;"	d	file:
ROOT2	misc.c	1363;"	d	file:
ROS	irregular/ros.cu	3;"	d	file:
ROS	regular/ros.cu	2;"	d	file:
ROSH	regular/ros.h	2;"	d
RType	metis.h	/^  int RType;			\/* The type of refinement *\/$/;"	m	struct:controldef
RUD	misc.c	2407;"	d	file:
RUD2	misc.c	2417;"	d	file:
RUD2	misc.c	2433;"	d	file:
RandomizeCoordinates	input/gen.c	/^int RandomizeCoordinates(int ntimes)$/;"	f
RcbPartition	misc.c	/^RcbPartition(int n_nodes, int n_ptnrs, double xyz[][3], int *ptnr, int *from, int *ind)$/;"	f
RcbPartition0	misc.c	/^RcbPartition0(int n_nodes, int n_ptnrs, double xyz[][3], int (*el)[2], int *ind)$/;"	f
ReadCoord	misc.c	/^ReadCoord(char *filename, int n_nodes, double xyz[][3])$/;"	f
ReadEdgeList	misc.c	/^ReadEdgeList(char *filename, int *n_nodes, int *n_edges, int el[][2])$/;"	f
ReadInputGraph	misc.c	/^ReadInputGraph(char *filename, int *n_nodes, int *n_edges, int el[][2])$/;"	f
ReadInputGraph2	misc.c	/^ReadInputGraph2(char *filename, int *n_nodes, int *n_edges, int *from, int *partners)$/;"	f
RebuildInteraction	input/gen.c	/^RebuildInteraction(double (*xyz)[3], int n_nodes, $/;"	f
RebuildInteraction	moldyn.cu	/^RebuildInteraction(double (*xyz)[3], int n_nodes, $/;"	f
RebuildNeighbor	moldyn.cu	/^void RebuildNeighbor()$/;"	f
Reduction_Object	regular/ros.h	/^struct Reduction_Object$/;"	s
Reduction_Object_C	irregular/roc.h	/^struct Reduction_Object_C$/;"	s
Reduction_Object_G	irregular/rog.h	/^struct Reduction_Object_G$/;"	s
Reduction_Object_GPU	regular/rog.h	/^struct Reduction_Object_GPU$/;"	s
Reduction_Object_S	irregular/ros.h	/^struct Reduction_Object_S$/;"	s
RefTmr	metis.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
RegularGetOutput	regular/regular_runtime.cu	/^struct output RegularRuntime::RegularGetOutput()$/;"	f	class:RegularRuntime
RegularInit	regular/regular_runtime.cu	/^void RegularRuntime::RegularInit()$/;"	f	class:RegularRuntime
RegularRuntime	regular/regular_runtime.cu	/^RegularRuntime::RegularRuntime($/;"	f	class:RegularRuntime
RegularRuntime	regular/regular_runtime.h	/^class RegularRuntime$/;"	c
RegularStart	regular/regular_runtime.cu	/^void RegularRuntime::RegularStart()$/;"	f	class:RegularRuntime
Reorder	irregular/reorder.cpp	/^Reorder::Reorder(int num_points, int num_edges, int num_dims, int *partitions)$/;"	f	class:Reorder
Reorder	irregular/reorder.h	/^class Reorder $/;"	c
RuntimeFinalize	include/runtime.cpp	/^void RuntimeFinalize()$/;"	f
RuntimeInit	include/runtime.cpp	/^void RuntimeInit(int argc, char *argv[])$/;"	f
SCALE_TIMESTEP	moldyn.h	85;"	d
SHARED_POOL_SIZE	regular/parameters.h	15;"	d
SHARED_SIZE	lib/common.h	22;"	d
SO	regular/ros.h	/^typedef struct Reduction_Object SO;  $/;"	t	typeref:struct:Reduction_Object
SORT_ALT	misc.c	391;"	d	file:
SQR	moldyn.h	17;"	d
SQRT	moldyn.h	15;"	d
SSizeArray	lib/array.h	/^typedef IntegerArray<ssize_t> SSizeArray;$/;"	t
STENCIL	stencil.h	2;"	d
STENCIL_CREATOR_H_	lib/stencil_creator.h	2;"	d
SepTmr	metis.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
SessionLoad	Session.vim	/^let SessionLoad = 1$/;"	v
SessionLoad	input/Session.vim	/^let SessionLoad = 1$/;"	v
SessionLoad	lib/Session.vim	/^let SessionLoad = 1$/;"	v
Set	lib/array.h	/^  void Set(PSIndex *buf) const {$/;"	f	class:IntegerArray
Set	lib/array.h	/^  void Set(ty v) {$/;"	f	class:IntegerArray
SetNoLessThan	lib/array.h	/^  void SetNoLessThan(const IntegerArray<ty> &x) {$/;"	f	class:IntegerArray
SetNoLessThan	lib/array.h	/^  void SetNoLessThan(const ty &x) {$/;"	f	class:IntegerArray
SetNoMoreThan	lib/array.h	/^  void SetNoMoreThan(const IntegerArray<ty> &x) {$/;"	f	class:IntegerArray
SetNoMoreThan	lib/array.h	/^  void SetNoMoreThan(const ty &x) {$/;"	f	class:IntegerArray
SizeArray	lib/array.h	/^typedef IntegerArray<size_t> SizeArray;$/;"	t
SizeVector	lib/array.h	/^typedef std::vector<size_t> SizeVector;$/;"	t
Sobject	irregular/ros.h	/^typedef struct Reduction_Object_S Sobject;$/;"	t	typeref:struct:Reduction_Object_S
SortDegree	misc.c	/^SortDegree(int *degree, int n_nodes, int *ind, int BiggestFirst)$/;"	f
SplitTmr	metis.h	/^        SepTmr, RefTmr, ProjectTmr, SplitTmr, AuxTmr1, AuxTmr2, AuxTmr3, AuxTmr4, AuxTmr5, AuxTmr6;$/;"	m	struct:controldef
StencilBegin	lib/stencil_runtime.cu	/^void StencilRuntime::StencilBegin()$/;"	f	class:StencilRuntime
StencilCreator	lib/stencil_creator.h	/^	StencilCreator(int num_dims, const IndexArray &global_size, int proc_num_dims, IntArray &proc_size, int stencil_width, int num_iters, bool periodic, bool diagonal):num_dims_(num_dims),global_size_(global_size),proc_num_dims_(proc_num_dims),proc_size_(proc_size),stencil_width_(stencil_width),num_iters_(num_iters)$/;"	f	class:StencilCreator
StencilCreator	lib/stencil_creator.h	/^class StencilCreator$/;"	c
StencilFinalize	lib/stencil_runtime.cu	/^void StencilRuntime::StencilFinalize()$/;"	f	class:StencilRuntime
StencilInit	lib/stencil_runtime.cu	/^void StencilRuntime::StencilInit()$/;"	f	class:StencilRuntime
StencilRuntime	lib/stencil_runtime.cu	/^StencilRuntime::StencilRuntime(int num_dims, int unit_size,$/;"	f	class:StencilRuntime
StencilRuntime	lib/stencil_runtime.h	/^class StencilRuntime$/;"	c
StringJoin	lib/util.h	/^  StringJoin(const std::string &sep=", "): sep(sep), first(true) {}$/;"	f	class:StringJoin
StringJoin	lib/util.h	/^class StringJoin$/;"	c
Swap	lib/grid.h	/^	void Swap()$/;"	f	class:Grid
T1	regular/gpu_kernel.cu	/^template <class T1, class T2> $/;"	v
TEMPERATURE	moldyn.h	82;"	d
TIMER	input/Makefile	/^TIMER  = ..\/timer$/;"	m
TOLERANCE	input/gen.c	11;"	d	file:
TOLERANCE	moldyn.h	86;"	d
TT_ATOM	moldyn.h	173;"	d
TT_BNEIGH	moldyn.h	154;"	d
TT_BNEIGH1	moldyn.h	155;"	d
TT_BNEIGH2	moldyn.h	156;"	d
TT_COMPF	moldyn.h	158;"	d
TT_COMPF1	moldyn.h	159;"	d
TT_COMPF2	moldyn.h	160;"	d
TT_COMPF3	moldyn.h	161;"	d
TT_ELEM	moldyn.h	174;"	d
TT_INSP	moldyn.h	157;"	d
TT_ITER	moldyn.h	175;"	d
TT_NET	moldyn.h	152;"	d
TT_UPCOOR	moldyn.h	153;"	d
TT_UPVEL	moldyn.h	162;"	d
Tile	lib/DS.h	/^struct Tile$/;"	s
TotalTmr	metis.h	/^  timer TotalTmr, InitPartTmr, MatchTmr, ContractTmr, CoarsenTmr, UncoarsenTmr, $/;"	m	struct:controldef
Tp	lib/time_util.cpp	/^    struct timeval Tp;$/;"	l
Tzp	lib/time_util.cpp	/^    struct timezone Tzp;$/;"	l
UNIT_SZ	misc.c	19;"	d	file:
USERDEFINE	moldyn.h	53;"	d
USE_SHARED	regular/parameters.h	21;"	d
UncoarsenTmr	metis.h	/^  timer TotalTmr, InitPartTmr, MatchTmr, ContractTmr, CoarsenTmr, UncoarsenTmr, $/;"	m	struct:controldef
UnsignedArray	lib/array.h	/^typedef IntegerArray<unsigned> UnsignedArray;$/;"	t
VALUE	irregular/parameters.h	/^typedef struct value VALUE;$/;"	t	typeref:struct:value
VEDegreeType	metis.h	/^typedef struct vedegreedef VEDegreeType;$/;"	t	typeref:struct:vedegreedef
VERBOSE	moldyn.h	50;"	d
VPInfoType	metis.h	/^typedef struct vpwgtdef VPInfoType;$/;"	t	typeref:struct:vpwgtdef
VRInfoType	metis.h	/^typedef struct vrinfodef VRInfoType;$/;"	t	typeref:struct:vrinfodef
W	main.cpp	17;"	d	file:
W	stencil.h	3;"	d
WARP_SIZE	regular/parameters.h	23;"	d
Width2	lib/DS.h	/^struct Width2 $/;"	s
WorkSpaceType	metis.h	/^typedef struct workspacedef WorkSpaceType;$/;"	t	typeref:struct:workspacedef
XYZ	misc.c	/^static double (*XYZ)[3];$/;"	v	file:
_OFFSET_TYPE	lib/data_util.h	9;"	d
_OFFSET_TYPE	lib/grid_util.h	39;"	d
__FUNC_ID__	lib/util.h	45;"	d
__LR_choice__	misc.c	/^static int __LR_choice__ = 0;$/;"	v	file:
__LR_coordinate__	misc.c	/^static double (*__LR_coordinate__)[3] = NULL;$/;"	v	file:
_dsize_	moldyn.cu	/^struct _dsize_ {$/;"	s	file:
a	input/gen.c	/^   int i, a, b, n= numMoles; $/;"	l
a	misc.c	/^    int a, i, j; $/;"	l
a	misc.c	/^    int i, j, k, a, npart;$/;"	l
abs_off_dst	lib/buffer_cuda.cu	/^		int abs_off_dst = get_linear_offset$/;"	l
abs_off_src	lib/buffer_cuda.cu	/^		int abs_off_src = get_linear_offset$/;"	l
accumulate	lib/array.h	/^  size_t accumulate(int len) const {$/;"	f	class:IntegerArray
accumulated	lib/stencil_runtime.cu	/^	int accumulated = 0;$/;"	l
adapt_graph	misc.c	/^adapt_graph(int num, ...)$/;"	f
adapt_graph2	misc.c	/^adapt_graph2(int num, ...)$/;"	f
adjncy	metis.h	/^  idxtype *adjncy;		\/* Array that stores the adjacency lists of nvtxs *\/$/;"	m	struct:graphdef
adjwgt	metis.h	/^  idxtype *adjwgt;		\/* Array that stores the weights of the adjacency lists *\/$/;"	m	struct:graphdef
adjwgtsum	metis.h	/^  idxtype *adjwgtsum;		\/* The sum of the adjacency weight of each vertex *\/$/;"	m	struct:graphdef
after	moldyn.cu	/^     double after = rtclock();$/;"	l
after_copy	moldyn.cu	/^	double after_copy = rtclock();$/;"	l
after_cpu	regular/regular_runtime.cu	/^	double after_cpu = rtclock();$/;"	l
after_gpu	irregular/irregular_runtime.cu	/^	double after_gpu = rtclock();$/;"	l
after_gpu	lib/stencil_runtime.cu	/^	double after_gpu = rtclock();$/;"	l
after_gpu	regular/regular_runtime.cu	/^	double after_gpu = rtclock();$/;"	l
after_launch	irregular/irregular_runtime.cu	/^	double after_launch = rtclock();$/;"	l
after_launch	lib/stencil_runtime.cu	/^		double after_launch = rtclock();$/;"	l
after_opt_time	misc.c	/^static double after_opt_time = 0.0;$/;"	v	file:
after_reduction	moldyn.cu	/^	double after_reduction = rtclock();$/;"	l
aftercopy	lib/grid_cuda.cu	/^	double aftercopy = rtclock();$/;"	l
afterload	km.cu	/^    	double afterload = rtclock();$/;"	l
afterreorder	moldyn.cu	/^     double afterreorder = rtclock();$/;"	l
align	regular/cpu_kernel_tools.cu	/^	unsigned int align(unsigned int size)$/;"	f
align	regular/gpu_kernel_tools.cu	/^__device__ unsigned int align(unsigned int size)$/;"	f
along	lib/stencil_runtime.h	/^	int along(){return along_;}$/;"	f	class:StencilRuntime
along_	lib/stencil_runtime.h	/^	int along_;$/;"	m	class:StencilRuntime
along_dim	lib/stencil_runtime.cu	/^void StencilRuntime::along_dim()$/;"	f	class:StencilRuntime
along_partitions_	lib/stencil_runtime.h	/^	int *along_partitions_;	$/;"	m	class:StencilRuntime
along_size	lib/stencil_runtime.cu	/^	int along_size = size[along_];$/;"	l
along_which	lib/stencil_runtime.cu	/^	int along_which = num_dims_ - 1;	$/;"	l
ap	misc.c	/^     va_list ap;$/;"	l
ap	misc.c	/^    va_list ap;$/;"	l
ap	misc.c	/^   va_list ap;$/;"	l
append	lib/util.h	/^  void append(const std::string &s) {$/;"	f	class:StringJoin
apply	misc.c	/^   int n_nodes, n_edges, (*el)[2], n, unit_sz, i, apply;$/;"	l
apply	misc.c	/^   int n_nodes, n_edges, *partners, *from, n, unit_sz, i, apply;$/;"	l
apply_cnt	misc.c	/^   static int apply_cnt;$/;"	l	file:
arg1	lib/stencil_runtime.cu	/^	void *arg1[3] = {&compute_type , &device_types[0], this};$/;"	l
arg1	lib/stencil_runtime.cu	/^	void *arg1[3] = {&compute_type, &device_types[0], this};$/;"	l
args	irregular/cpu_kernel.cu	/^	struct init_args *args = (struct init_args *)arg;$/;"	l
args	irregular/cpu_kernel.cu	/^	struct merge_args *args = (struct merge_args *)arg;$/;"	l
args	irregular/cpu_kernel.cu	/^    CpuArgs *args = (CpuArgs *)arg;$/;"	l
args	irregular/irregular_runtime.cu	/^        CpuArgs args[CPU_THREADS];$/;"	l
args	lib/compute_cpu.cpp	/^	Cargs *args = (Cargs *)arg;		$/;"	l
args	lib/stencil_runtime.cu	/^		Cargs args[CPU_THREADS];	$/;"	l
args	regular/cpu_kernel.cu	/^    struct cpu_args_reg *args = (struct cpu_args_reg *)arg;$/;"	l
args	regular/regular_runtime.cu	/^	struct cpu_args_reg args[CPU_THREADS];	$/;"	l
array_	irregular/reduction_array.h	/^	void *array_;$/;"	m	class:reduction_array
auxcore	metis.h	/^  idxtype *auxcore;			\/* This points to the memory of the edegrees *\/$/;"	m	struct:workspacedef
ave	regular/gpu_kernel_tools.cu	/^	int ave = block_size\/num_groups;	$/;"	l
average	irregular/partition_util.cpp	/^	double average = ceil((double)global_num_nodes\/num_procs);$/;"	l
average	irregular/partition_view.cpp	/^	int average = global_num_nodes_\/num_procs_; $/;"	l
average	regular/splitter.cpp	/^	int average = num_offsets_\/num_procs_;$/;"	l
avg_dist	misc.c	/^    double dist, tot_dist, avg_dist;$/;"	l
avg_dist2	misc.c	/^    double tot_dist2, avg_dist2, begin_time;$/;"	l
b	input/gen.c	/^   int i, a, b, n= numMoles; $/;"	l
before	moldyn.cu	/^     double before = rtclock();$/;"	l
before_copy	moldyn.cu	/^	double before_copy = rtclock();$/;"	l
before_cpu	regular/regular_runtime.cu	/^	double before_cpu = rtclock();$/;"	l
before_gpu	irregular/irregular_runtime.cu	/^	double before_gpu = rtclock();$/;"	l
before_gpu	lib/stencil_runtime.cu	/^	double before_gpu = rtclock();$/;"	l
before_gpu	regular/regular_runtime.cu	/^	double before_gpu = rtclock();$/;"	l
before_launch	irregular/irregular_runtime.cu	/^	double before_launch = rtclock();$/;"	l
before_launch	lib/stencil_runtime.cu	/^		double before_launch = rtclock();$/;"	l
before_opt_time	misc.c	/^static double before_opt_time = 0.0;$/;"	v	file:
before_reduction	moldyn.cu	/^	double before_reduction = rtclock();$/;"	l
beforecopy	lib/grid_cuda.cu	/^	double beforecopy = rtclock();$/;"	l
beforeload	km.cu	/^    	double beforeload = rtclock();$/;"	l
begin	misc.c	/^    int i,j, begin, cur;$/;"	l
begin_time	misc.c	/^    double tot_dist2, avg_dist2, begin_time;$/;"	l
bfsprocess	misc.c	/^bfsprocess(int n_nodes, int n_edges, int (*el)[2], int n, long (*repos)[2])$/;"	f
bfsprocess2	misc.c	/^bfsprocess2(int n_nodes, int n_edges, int *partners, int *from, int n, long (*repos)[2])$/;"	f
bid	irregular/gpu_kernel.cu	/^    const unsigned int bid = blockIdx.x;$/;"	l
bid	lib/compute_cuda.cu	/^    	const unsigned int bid = blockIdx.x;$/;"	l
bid	regular/rog.cu	/^		unsigned int bid = blockIdx.x;$/;"	l
bid	regular/rog.cu	/^	const unsigned int bid = blockIdx.x;$/;"	l
bitonic_merge	regular/rog.cu	/^__device__ void Reduction_Object_GPU::bitonic_merge(unsigned int *testdata, unsigned int k, unsigned int j)$/;"	f	class:Reduction_Object_GPU
bitonic_sort	regular/ros.cu	/^__device__ void Reduction_Object::bitonic_sort(int *testdata)$/;"	f	class:Reduction_Object
block	irregular/irregular_runtime.cu	/^		compute_gpu<<<grid, block, 0>>>$/;"	l
block	lib/buffer_cuda.cu	/^		copy_halo_3D<double><<<grid, block, 0, stream>>>$/;"	l
block	lib/buffer_cuda.cu	/^		copy_halo_3D<float><<<grid, block, 0, stream>>>$/;"	l
block	lib/stencil_runtime.cu	/^		compute_cuda_internal<<<grid, block, 0>>>$/;"	l
block_size	lib/compute_cuda.cu	/^    	const unsigned int block_size = blockDim.x;$/;"	l
bndind	metis.h	/^  idxtype *bndptr, *bndind;$/;"	m	struct:graphdef
bndptr	metis.h	/^  idxtype *bndptr, *bndind;$/;"	m	struct:graphdef
border_tiles	lib/stencil_runtime.h	/^	vector<struct Tile> *border_tiles;$/;"	m	class:StencilRuntime
boxSize	input/gen.c	/^int 	 boxSize;$/;"	v
boxSize	moldyn.cu	/^int 	  boxSize;$/;"	v
bp	misc.c	/^    int i, p, lb, ub, pt, bp, ip, jp, localI, localP;$/;"	l
bubblesort	misc.c	/^bubblesort(int start, int end)$/;"	f
bubblesort2	misc.c	/^bubblesort2(int *partners, int n)$/;"	f
bucket1	regular/rog.cu	/^	unsigned long long int bucket1 = buckets[bucket_index1];$/;"	l
bucket1	regular/ros.cu	/^	int bucket1 = buckets[bucket_index1];$/;"	l
bucket2	regular/rog.cu	/^	unsigned long long int bucket2 = buckets[bucket_index2];$/;"	l
bucket2	regular/ros.cu	/^	int bucket2 = buckets[bucket_index2];$/;"	l
buckets	metis.h	/^  ListNodeType **buckets;$/;"	m	struct:PQueueType
buckets	regular/roc.h	/^        struct intl buckets[NUM_BUCKETS_G];$/;"	m	struct:roc	typeref:struct:roc::intl
buckets	regular/rog.h	/^		unsigned long long int buckets[NUM_BUCKETS_G]; $/;"	m	struct:Reduction_Object_GPU
buckets	regular/ros.h	/^		int buckets[NUM_BUCKETS_S]; \/\/every bucket contains an integer, which is two shorts, indices of key and value $/;"	m	struct:Reduction_Object
buf	lib/grid_cpu.cpp	/^	BufferHost *buf = buffer();\/\/fw? halo_peer_fw_[dim]:halo_peer_bw_[dim];$/;"	l
buf_	lib/buffer.h	/^	void *buf_;$/;"	m	class:Buffer
buf_d_	lib/buffer_cuda.h	/^	void *buf_d_;$/;"	m	class:BufferCUDAHost
buffer	lib/grid.h	/^	BufferHost *buffer() const$/;"	f	class:Grid
buffer	lib/grid_cuda.h	/^	BufferCUDADev *buffer()$/;"	f	class:GridCuda
buffer_cpu_recv	lib/grid_cuda.h	/^	BufferCUDAHost *buffer_cpu_recv(){return buffer_cpu_recv_;}$/;"	f	class:GridCuda
buffer_cpu_recv_	lib/grid_cuda.cu	/^		delete buffer_cpu_recv_;$/;"	l
buffer_cpu_recv_	lib/grid_cuda.h	/^	BufferCUDAHost *buffer_cpu_recv_;   \/\/used for copying from CPU grid$/;"	m	class:GridCuda
buffer_cpu_send	lib/grid_cuda.h	/^	BufferCUDAHost *buffer_cpu_send(){return buffer_cpu_send_;}$/;"	f	class:GridCuda
buffer_cpu_send_	lib/grid_cuda.cu	/^		delete buffer_cpu_send_;$/;"	l
buffer_cpu_send_	lib/grid_cuda.h	/^	BufferCUDAHost *buffer_cpu_send_;   \/\/used for copying to CPU grid$/;"	m	class:GridCuda
buffer_global	lib/grid_cuda.h	/^	BufferCUDAHost *buffer_global(){return buffer_global_;}$/;"	f	class:GridCuda
buffer_global_	lib/grid_cuda.cu	/^		delete buffer_global_;$/;"	l
buffer_global_	lib/grid_cuda.h	/^	BufferCUDAHost *buffer_global_; \/\/used for copying to global grid$/;"	m	class:GridCuda
bw	lib/DS.h	/^  	UnsignedArray bw;$/;"	m	struct:Width2
bw_neighbors	lib/grid_view.h	/^	IndexArray bw_neighbors;$/;"	m	class:Grid_view
bw_peer	lib/grid_view.cpp	/^	int bw_peer = bw_neighbors[dim]; $/;"	l
bw_peer	lib/grid_view.cpp	/^        	        << " for fw access to " << bw_peer << "\\n";$/;"	l
bw_peer	lib/grid_view.cpp	/^                << " bytes for bw access from " << bw_peer << "\\n";$/;"	l
bw_size	lib/grid_view.cpp	/^	size_t bw_size = grid->CalcHaloSize(dim, halo_bw_width) * grid->unit_size();$/;"	l
byte	misc.c	/^typedef unsigned char byte;$/;"	t	file:
cargs	lib/cpu_util.h	/^struct cargs$/;"	s
ccore	metis.h	/^  int maxcore, ccore;$/;"	m	struct:workspacedef
cdegree	metis.h	/^  int cdegree;$/;"	m	struct:workspacedef
centers	km.cu	/^	float *centers = (float *)malloc(sizeof(float)*KMEANS_DIM*K);$/;"	l
check	input/gen.c	/^    int *check, check_OK=1;$/;"	l
check	moldyn.cu	/^    int *check, check_OK=1;$/;"	l
checkCUDAError	lib/cu_util.cu	/^void checkCUDAError(const char *msg)$/;"	f
check_OK	input/gen.c	/^    int *check, check_OK=1;$/;"	l
check_OK	moldyn.cu	/^    int *check, check_OK=1;$/;"	l
chunk	input/gen.c	/^    int chunk = numMoles \/ nproc;$/;"	l
clean_grids	lib/stencil_runtime.cu	/^void StencilRuntime::clean_grids()$/;"	f	class:StencilRuntime
cluster_dim1	regular.h	/^                float cluster_dim1 = ((float *)parameter)[KMEANS_DIM*i];$/;"	l
cluster_dim2	regular.h	/^                float cluster_dim2 = ((float *)parameter)[KMEANS_DIM*i+1];$/;"	l
cluster_dim3	regular.h	/^                float cluster_dim3 = ((float *)parameter)[KMEANS_DIM*i+2];$/;"	l
cmap	metis.h	/^  idxtype *cmap;$/;"	m	struct:graphdef
cnt	misc.c	/^    int  *nodes, *degree, *cnt, *ind2, *nodes2, *tp;$/;"	l
cnt	misc.c	/^    int *cnt, *ind2;$/;"	l
cnt	misc.c	/^    static int cnt = 0;$/;"	l	file:
cnt	misc.c	/^  int i, k, cnt, edge;$/;"	l
coarser	metis.h	/^  struct graphdef *coarser, *finer;$/;"	m	struct:graphdef	typeref:struct:graphdef::graphdef
compar	misc.c	/^int compar(const void *a, const void *b)$/;"	f
compare	regular.h	/^DEVICE int compare(void *&key1, unsigned short &key1_size, void *&key2, unsigned short &key2_size, void *&value1, unsigned short value1_size,  void *&value2, unsigned short value2_size)$/;"	f	namespace:FFGPU
compare	regular/rog.cu	/^	int compare = 0;$/;"	l
compare_value	regular/rog.cu	/^	int compare_value = 0;$/;"	l
compare_value	regular/ros.cu	/^	int compare_value = 0;$/;"	l
compute_cpu	irregular/cpu_kernel.cu	/^void *compute_cpu(void *arg)$/;"	f
compute_cpu_reg	regular/cpu_kernel.cu	/^void *compute_cpu_reg(void *arg)$/;"	f
compute_cuda_internal	lib/compute_cuda.cu	/^__global__ void compute_cuda_internal$/;"	f
compute_gpu	irregular/gpu_kernel.cu	/^__global__ void compute_gpu($/;"	f
compute_gpu	regular/gpu_kernel.cu	/^__global__ void compute_gpu($/;"	f
compute_stream_	lib/grid_cuda.h	/^	cudaStream_t compute_stream_;$/;"	m	class:GridCuda
compute_tiles	lib/compute_cpu.cpp	/^void *compute_tiles(void *arg)$/;"	f
compute_type	lib/stencil_runtime.cu	/^	int *compute_type = (int *)((void **)arg)[0];$/;"	l
compute_type	lib/stencil_runtime.cu	/^	int compute_type = BORDER;$/;"	l
compute_type	lib/stencil_runtime.cu	/^	int compute_type = INTERNAL;$/;"	l
continuous	input/gen.c	/^int      continuous = 1;$/;"	v
continuous	lib/data_util.cpp	/^	bool continuous = true;$/;"	l
continuous	lib/grid_util.cc	/^  bool continuous = true;$/;"	l
controldef	metis.h	/^struct controldef {$/;"	s
coordi_swap	misc.c	/^     int  siz, siz0 = 0, coordi_swap;$/;"	l
coordinate_size_	irregular/irregular_runtime.h	/^	int coordinate_size_;$/;"	m	class:IrregularRuntime
copy_device_to_map	lib/grid_cuda.cu	/^void GridCuda::copy_device_to_map(int dim, unsigned width, bool fw)$/;"	f	class:GridCuda
copy_from_bottom	lib/grid_cpu.cpp	/^void GridCPU::copy_from_bottom(int dim, int stencil_width, GridMPI *grid_global)$/;"	f	class:GridCPU
copy_from_global_grid	lib/grid_cpu.cpp	/^void GridCPU::copy_from_global_grid(GridMPI *grid_global, int dim, int along_start, int along_length, unsigned width, bool fw)$/;"	f	class:GridCPU
copy_from_neighbor_map	lib/grid_cuda.cu	/^void GridCuda::copy_from_neighbor_map(int dim, int stencil_width, GridMPI *grid_global)$/;"	f	class:GridCuda
copy_from_top	lib/grid_cuda.cu	/^void GridCuda::copy_from_top(int dim, int stencil_width, GridMPI *grid_global)$/;"	f	class:GridCuda
copy_global_grid_to_map	lib/grid_cuda.cu	/^void GridCuda::copy_global_grid_to_map(GridMPI *grid_global, int dim, int along_start, int along_length, unsigned width, bool fw)$/;"	f	class:GridCuda
copy_halo_3D	lib/buffer_cuda.cu	/^__global__ void copy_halo_3D$/;"	f
copy_host_to_device	lib/grid_cuda.cu	/^void GridCuda::copy_host_to_device(IndexArray &my_offset,$/;"	f	class:GridCuda
copy_host_to_host	lib/grid_cpu.cpp	/^void GridCPU::copy_host_to_host(IndexArray &my_offset, IndexArray &src_offset, BufferHost *src, IndexArray &size)$/;"	f	class:GridCPU
copy_in	lib/buffer.cpp	/^void BufferHost::copy_in(BufferHost *src, $/;"	f	class:BufferHost
copy_in_from_host	lib/buffer_cuda.cu	/^void BufferCUDADev::copy_in_from_host(BufferHost *src, $/;"	f	class:BufferCUDADev
copy_in_from_map	lib/buffer_cuda.cu	/^void BufferCUDADev::copy_in_from_map(BufferCUDAHost *source, $/;"	f	class:BufferCUDADev
copy_in_or_out	lib/buffer.cpp	/^void BufferHost::copy_in_or_out(BufferHost *src, $/;"	f	class:BufferHost
copy_in_or_out	lib/buffer_cuda.cu	/^void BufferCUDADev::copy_in_or_out(BufferHost *source, $/;"	f	class:BufferCUDADev
copy_in_stream_	lib/grid_cuda.h	/^	cudaStream_t copy_in_stream_;$/;"	m	class:GridCuda
copy_map_to_device	lib/grid_cuda.cu	/^void GridCuda::copy_map_to_device(int dim, unsigned width, bool fw)$/;"	f	class:GridCuda
copy_map_to_global_grid	lib/grid_cuda.cu	/^void GridCuda::copy_map_to_global_grid(GridMPI *grid_global, int dim, int along_start, int along_length, unsigned width, bool fw)$/;"	f	class:GridCuda
copy_map_to_neighbor	lib/grid_cuda.cu	/^void GridCuda::copy_map_to_neighbor(int dim, int stencil_width, GridMPI *grid_global, GridCPU *grid_cpu)$/;"	f	class:GridCuda
copy_out	lib/buffer.cpp	/^void BufferHost::copy_out(BufferHost *src, $/;"	f	class:BufferHost
copy_out_stream_	lib/grid_cuda.h	/^	cudaStream_t copy_out_stream_;$/;"	m	class:GridCuda
copy_out_to_host	lib/buffer_cuda.cu	/^void BufferCUDADev::copy_out_to_host(BufferHost *src, $/;"	f	class:BufferCUDADev
copy_out_to_map	lib/buffer_cuda.cu	/^void BufferCUDADev::copy_out_to_map(BufferCUDAHost *dest, $/;"	f	class:BufferCUDADev
copy_size	lib/grid_cpu.cpp	/^	IndexArray copy_size = my_real_size_;$/;"	l
copy_size	lib/grid_cuda.cu	/^		IndexArray copy_size = my_real_size_;$/;"	l
copy_size	lib/grid_cuda.cu	/^	IndexArray copy_size = my_real_size_;$/;"	l
copy_time	moldyn.cu	/^  double copy_time = 0;$/;"	l
copy_to_global_grid	lib/grid_cpu.cpp	/^void GridCPU::copy_to_global_grid(GridMPI *grid_global, int dim, int along_start, int along_length, unsigned width, bool fw)$/;"	f	class:GridCPU
copy_val	regular/cpu_kernel_tools.cu	/^	void copy_val(void *dst, void *src, unsigned size)$/;"	f
copy_val	regular/gpu_kernel_tools.cu	/^__device__ void copy_val(void *dst, void *src, unsigned size)$/;"	f
core	metis.h	/^  idxtype *core;			\/* Where pairs, indices, and degrees are coming from *\/$/;"	m	struct:workspacedef
count	irregular/partition_view.cpp	/^	int count;$/;"	l
count	irregular/partitioner.cpp	/^	size_t count = 0;$/;"	l
count	irregular/reorder.cpp	/^	int count = 0;$/;"	l
count	lib/cu_util.cu	/^        int count;$/;"	l
count	misc.c	/^    int i, *count, *count2, *tmp, *tmp2, *p;$/;"	l
count	moldyn.cu	/^  double   count, vel ;$/;"	l
count	regular/regular_runtime.cu	/^	int count = 0;$/;"	l
count	stencil.h	/^	int count = 0;$/;"	l
count2	misc.c	/^    int i, *count, *count2, *tmp, *tmp2, *p;$/;"	l
count_0	irregular/reorder.cpp	/^	int count_0= 0,count_1=0;$/;"	l
count_1	irregular/reorder.cpp	/^	int count_0= 0,count_1=0;$/;"	l
counter	moldyn.cu	/^  double vaverh, velocity, counter, sq;$/;"	l
cpackprocess	misc.c	/^cpackprocess(int n_nodes, int n_edges, int (*el)[2], int n, long (*repos)[2])$/;"	f
cpackprocess2	misc.c	/^cpackprocess2(int n_nodes, int n_edges, int *partners, int *from, int n, long (*repos)[2])$/;"	f
cpu_args	irregular/cpu_args.h	/^struct cpu_args$/;"	s
cpu_args_reg	regular/args.h	/^struct cpu_args_reg$/;"	s
cpu_edge_offset_	irregular/irregular_runtime.h	/^	int *cpu_edge_offset_;$/;"	m	class:IrregularRuntime
cpu_edge_vectors	irregular/partitioner.h	/^	vector<struct edge> **cpu_edge_vectors;$/;"	m	class:Partitioner
cpu_edges	irregular/partitioner.h	/^	EDGE *cpu_edges;$/;"	m	class:Partitioner
cpu_gpu_split_point	irregular/partitioner.h	/^	int cpu_gpu_split_point;$/;"	m	struct:partition_args
cpu_new_edges	irregular/partitioner.h	/^	int cpu_new_edges;$/;"	m	class:Partitioner
cpu_nodes_per_partition	irregular/partitioner.h	/^	int cpu_nodes_per_partition;$/;"	m	class:Partitioner
cpu_partition	irregular/partitioner.h	/^	int *cpu_partition;$/;"	m	struct:partition_args
cpu_partitions	irregular/partitioner.h	/^	int *cpu_partitions;$/;"	m	class:Partitioner
cpu_parts	irregular/partitioner.h	/^	Part *cpu_parts;$/;"	m	class:Partitioner
cpu_total_edges	irregular/partitioner.cpp	/^	int cpu_total_edges = get_cpu_num_edges();$/;"	l
cpu_total_num_nodes_	irregular/partitioner.h	/^	int cpu_total_num_nodes_;$/;"	m	class:Partitioner
cpu_total_num_partitions_	irregular/partitioner.h	/^	int cpu_total_num_partitions_;$/;"	m	class:Partitioner
create_grids	lib/stencil_runtime.cu	/^void StencilRuntime::create_grids()$/;"	f	class:StencilRuntime
cross_edges	irregular/partition_view.cpp	/^	vector<EDGE> cross_edges;$/;"	l
cur	irregular/partition_view.cpp	/^			int cur = my_num_nodes_ + remote_node_sum_[i];	$/;"	l
cur	misc.c	/^    int i, j, k, degree, max, root=0, p, cur, last, reverse = 1;$/;"	l
cur	misc.c	/^    int i,j, begin, cur;$/;"	l
cur0	lib/buffer_cuda.cu	/^	int cur0, cur1, cur2;$/;"	l
cur1	lib/buffer_cuda.cu	/^	int cur0, cur1, cur2;$/;"	l
cur2	lib/buffer_cuda.cu	/^	int cur0, cur1, cur2;$/;"	l
cur_device	lib/stencil_runtime.cu	/^		int cur_device;$/;"	l
cur_dimension	misc.c	/^static int cur_dimension;$/;"	v	file:
cur_edge	irregular/partitioner.cpp	/^	EDGE cur_edge;$/;"	l
cur_max_part	misc.c	/^    int  max_degree, init_max_part, cur_max_part, m, max;$/;"	l
cur_offset	lib/data_util.cpp	/^      			const IndexArray &cur_offset = *oit;$/;"	l
cur_offset	lib/grid_util.cc	/^      const IndexArray &cur_offset = *oit;$/;"	l
current_iter_	irregular/irregular_runtime.h	/^	int current_iter_;$/;"	m	class:IrregularRuntime
current_iter_	lib/stencil_runtime.h	/^	int current_iter_;$/;"	m	class:StencilRuntime
current_tile	lib/compute_cuda.cu	/^	__shared__ Ltile current_tile;$/;"	l
cut_edge	input/gen.c	/^    int i, p1, p2, cut_edge = 0;$/;"	l
cutoffRadius	input/gen.c	/^double   cutoffRadius;          \/*  cuttoff distance for interactions     *\/$/;"	v
cutoffRadius	irregular.h	/^		double cutoffRadius = pa->cutoffRadius;$/;"	l
cutoffRadius	moldyn.cu	/^         cutoffRadius,          \/*  cuttoff distance for interactions     *\/$/;"	v
cutoffRadius	moldyn.h	/^	double cutoffRadius;$/;"	m	struct:para
cutoffRadius	moldyn.h	/^         cutoffRadius,          \/*  cuttoff distance for interactions     *\/$/;"	v
cutoffSquare	input/gen.c	/^    double sideHalf, cutoffSquare, rd, xx, yy, zz;$/;"	l
cutoffSquare	input/gen.c	/^  double cutoffSquare, xx, yy, zz, rd;$/;"	l
cutoffSquare	irregular.h	/^		double cutoffSquare = cutoffRadius * cutoffRadius; $/;"	l
cutoffSquare	moldyn.cu	/^	   double cutoffSquare = (cutoffRadius * TOLERANCE)*(cutoffRadius * TOLERANCE);$/;"	l
cutoffSquare	moldyn.cu	/^    double sideHalf, cutoffSquare, rd, xx, yy, zz;$/;"	l
cutoffSquare	moldyn.cu	/^  double cutoffSquare;$/;"	l
d	regular/cpu_kernel_tools.cu	/^	         char *d= (char *)dst;$/;"	l
d	regular/gpu_kernel_tools.cu	/^         char *d=(char*)dst;$/;"	l
d	regular/splitter.cpp	/^	data_partition_mpi *d = new data_partition_mpi(my_input, my_input_size, my_offset, my_num_offsets_);$/;"	l
dabs	misc.c	2599;"	d	file:
data	lib/grid.h	/^	char *data() const$/;"	f	class:Grid
data	lib/test/test_util.h	/^      sj << data[i];$/;"	l
data	lib/test/test_util.h	/^  T *data = (T*)g->data();$/;"	l
data_	lib/grid.h	/^	char *data_[2];$/;"	m	class:Grid
data_	lib/grid_cuda.h	/^	char *data_[2];$/;"	m	class:GridCuda
data_buffer_	lib/grid.h	/^	BufferHost *data_buffer_[2];$/;"	m	class:Grid
data_buffer_	lib/grid_cuda.h	/^	BufferCUDADev *data_buffer_[2];$/;"	m	class:GridCuda
data_h	moldyn.cu	/^     struct point_data *data_h = (struct point_data *)malloc(sizeof(struct point_data)*NUM_POINTS);$/;"	l
data_in	lib/grid.h	/^	char *data_in()$/;"	f	class:Grid
data_in	lib/grid_cuda.h	/^	char *data_in()$/;"	f	class:GridCuda
data_offset	regular/cpu_kernel.cu	/^    Offset *data_offset = runtime->offsets_pin_;$/;"	l
data_out	lib/grid.h	/^	char *data_out()$/;"	f	class:Grid
data_out	lib/grid_cuda.h	/^	char *data_out()$/;"	f	class:GridCuda
data_partition_mpi	regular/data_partition_mpi.cu	/^data_partition_mpi::data_partition_mpi(void *input,$/;"	f	class:data_partition_mpi
data_partition_mpi	regular/data_partition_mpi.h	/^class data_partition_mpi$/;"	c
data_tmp	irregular/partition_view.cpp	/^				char *data_tmp = p_node_data + node_id * node_data_elm_size_;$/;"	l
dbglvl	metis.h	/^  int dbglvl;			\/* Controls the debuging output of the program *\/$/;"	m	struct:controldef
degree	misc.c	/^    int  *nodes, *degree, *cnt, *ind2, *nodes2, *tp;$/;"	l
degree	misc.c	/^    int i, j, k, degree, max, root=0, p, cur, last, reverse = 1;$/;"	l
deleter_	lib/buffer.h	/^	void (*deleter_)(void *ptr);$/;"	m	class:Buffer
device_id	irregular/partitioner.cpp	/^		int device_id = get_device_id(i);$/;"	l
device_id	lib/grid_cuda.h	/^	int device_id(){return device_id_;} $/;"	f	class:GridCuda
device_id_	lib/grid_cpu.h	/^	int device_id_;$/;"	m	class:GridCPU
device_id_	lib/grid_cuda.h	/^	int device_id_;$/;"	m	class:GridCuda
device_node_start_	irregular/irregular_runtime.h	/^	int *device_node_start_;$/;"	m	class:IrregularRuntime
device_node_sum_	irregular/irregular_runtime.h	/^	int *device_node_sum_;$/;"	m	class:IrregularRuntime
device_num_nodes	irregular/partitioner.cpp	/^		int device_num_nodes = i==0? cpu_total_num_nodes_:gpu_total_num_nodes_[i - 1];$/;"	l
device_num_nodes_sum_	irregular/partitioner.h	/^	int *device_num_nodes_sum_;$/;"	m	class:Partitioner
device_offset	regular/cpu_kernel.cu	/^    int *device_offset = runtime->task_offset_; \/\/used for competing$/;"	l
device_offsets_d	regular/regular_runtime.h	/^	int **device_offsets_d;$/;"	m	class:RegularRuntime
device_offsets_h	regular/regular_runtime.h	/^	int **device_offsets_h;$/;"	m	class:RegularRuntime
device_start	irregular/partitioner.cpp	/^		int device_start = device_num_nodes_sum_[i];$/;"	l
device_type	lib/stencil_runtime.cu	/^	int device_type = *ptr_type;$/;"	l
device_types	lib/stencil_runtime.cu	/^	int device_types[2];$/;"	l
device_x	irregular/partitioner.cpp	/^	int device_x, device_y;$/;"	l
device_y	irregular/partitioner.cpp	/^	int device_x, device_y;$/;"	l
dim	misc.c	/^    int dim = cur_dimension;$/;"	l
dim0	km.cu	/^    float dim0;$/;"	m	struct:kmeans_value	file:
dim0_tiles	lib/data_util.cpp	/^		int dim0_tiles = ceil((double)size[0]\/tile_size);$/;"	l
dim1	km.cu	/^    float dim1;$/;"	m	struct:kmeans_value	file:
dim1	regular.h	/^        float dim1 = start[0];$/;"	l
dim1_tiles	lib/data_util.cpp	/^		int dim1_tiles = ceil((double)size[1]\/tile_size);$/;"	l
dim2	km.cu	/^    float dim2;$/;"	m	struct:kmeans_value	file:
dim2	regular.h	/^        float dim2 = start[1];$/;"	l
dim2_tiles	lib/data_util.cpp	/^		int dim2_tiles = ceil((double)size[2]\/tile_size);$/;"	l
dim3	regular.h	/^        float dim3 = start[2];$/;"	l
dims_d	lib/stencil_runtime.cu	/^		int *dims_d;$/;"	l
dist	km.cu	/^    float dist;$/;"	m	struct:kmeans_value	file:
dist	misc.c	/^    double dist, tot_dist, avg_dist;$/;"	l
dist	regular.h	/^        float dist;$/;"	l
dist1	regular.h	/^        float dist1 = ((float *)value1)[4];$/;"	l
dist2	regular.h	/^        float dist2 = ((float *)value2)[4];$/;"	l
do_merge	regular/gpu_kernel.cu	/^    __shared__ int do_merge;$/;"	l
do_work	irregular/roc.cu	/^	bool do_work = true;$/;"	l
do_work	irregular/rog.cu	/^        bool do_work = true;$/;"	l
do_work	irregular/ros.cu	/^        bool do_work = true;$/;"	l
done	lib/data_util.cpp	/^    		bool done = false;$/;"	l
done	lib/grid_util.cc	/^    bool done = false;$/;"	l
done	misc.c	/^    int  i, j, k, t, n_pieces, root, root2, p, done, iter, real_i;$/;"	l
dp_mpi_	regular/regular_runtime.h	/^	data_partition_mpi * dp_mpi_;$/;"	m	class:RegularRuntime
drand_x	moldyn.cu	/^double drand_x()$/;"	f
dsize	moldyn.cu	/^} dsize;$/;"	v	typeref:struct:_dsize_
dst	lib/grid_cpu.cpp	/^	GridCPU *dst = this;$/;"	l
dst	lib/grid_cpu.cpp	/^	GridMPI *dst = grid_global;$/;"	l
dst	lib/grid_cuda.cu	/^		GridCuda *dst = grid_cuda[gpu_id + 1];$/;"	l
dst	lib/grid_cuda.cu	/^		GridCuda *dst = grid_cuda[gpu_id - 1];$/;"	l
dst	lib/grid_cuda.cu	/^		GridCuda *dst = this;	$/;"	l
dst	lib/grid_cuda.cu	/^		GridMPI *dst = grid_global;$/;"	l
dst	lib/grid_mpi.cu	/^  	void *dst = buffer()->Get();$/;"	l
dst	lib/grid_mpi.cu	/^                dst, my_real_size(),$/;"	l
dst	lib/grid_mpi.cu	/^                dst, offset, my_size());$/;"	l
dst_abs0	lib/buffer_cuda.cu	/^	int dst_abs0, dst_abs1, dst_abs2;$/;"	l
dst_abs1	lib/buffer_cuda.cu	/^	int dst_abs0, dst_abs1, dst_abs2;$/;"	l
dst_abs2	lib/buffer_cuda.cu	/^	int dst_abs0, dst_abs1, dst_abs2;$/;"	l
dst_addr	lib/buffer.cpp	/^	char *dst_addr = (char *)Get();$/;"	l
dst_addr	lib/buffer_cuda.cu	/^	char *dst_addr = (char *)Get();$/;"	l
dst_cuda	lib/grid_cpu.cpp	/^	GridCuda *dst_cuda = grid_cuda[0];			$/;"	l
dst_ptr	lib/data_util.cpp	/^      			void *dst_ptr;$/;"	l
dst_ptr	lib/grid_util.cc	/^      void *dst_ptr;$/;"	l
dst_start	lib/buffer.cpp	/^	IndexArray dst_start;$/;"	l
dst_start	lib/buffer_cuda.cu	/^	IndexArray dst_start;$/;"	l
ed	irregular/partitioner.cpp	/^                int ed = start + (j + 1) * num_points_per_part - 1;$/;"	l
ed	irregular/reorder.cpp	/^		int ed = start + (j + 1) * num_points_per_part - 1;$/;"	l
ed	metis.h	/^  idxtype *id, *ed;$/;"	m	struct:graphdef
ed	metis.h	/^  idxtype ed, ned;$/;"	m	struct:vedegreedef
ed	metis.h	/^  idxtype ed;$/;"	m	struct:edegreedef
ed	metis.h	/^ int id, ed, nid;            	\/* ID\/ED of nodes *\/$/;"	m	struct:vrinfodef
ed	metis.h	/^ int id, ed;            	\/* ID\/ED of nodes *\/$/;"	m	struct:rinfodef
edegreedef	metis.h	/^struct edegreedef {$/;"	s
edegrees	metis.h	/^  EDegreeType *edegrees;$/;"	m	struct:workspacedef
edegrees	metis.h	/^ EDegreeType *edegrees;     	\/* List of edges *\/$/;"	m	struct:rinfodef
edegrees	metis.h	/^ VEDegreeType *edegrees;     	\/* List of edges *\/$/;"	m	struct:vrinfodef
edegrees	metis.h	/^ idxtype edegrees[2];  $/;"	m	struct:nrinfodef
edge	irregular/data_type.h	/^struct edge$/;"	s
edge	misc.c	/^  int i, k, cnt, edge;$/;"	l
edge	misc.c	/^  int i, k, edge;$/;"	l
edge_data	irregular/cpu_kernel.cu	/^    void *edge_data = p_cpu->my_edges();$/;"	l
edge_data	irregular/partition_view.cpp	/^	char *edge_data = NULL;$/;"	l
edge_data_elm_size	irregular/partition.h	/^	int edge_data_elm_size(){return edge_data_elm_size_;}$/;"	f	class:partition
edge_data_elm_size_	irregular/irregular_runtime.h	/^	int edge_data_elm_size_;$/;"	m	class:IrregularRuntime
edge_data_elm_size_	irregular/partition.h	/^	int edge_data_elm_size_;$/;"	m	class:partition
edge_data_elm_size_	irregular/partition_view.h	/^	int edge_data_elm_size_;$/;"	m	class:partition_view
edge_ids	irregular/partition_view.cpp	/^	vector<int> edge_ids;$/;"	l
edge_left	misc.c	394;"	d	file:
edge_list	misc.c	/^int (*edge_list)[2];$/;"	v
edge_right	misc.c	395;"	d	file:
edge_tmp	irregular/partition_view.cpp	/^	EDGE edge_tmp;$/;"	l
edge_vectors	irregular/reorder.h	/^	vector<struct edge> **edge_vectors;$/;"	m	class:Reorder
edgecut	misc.c	/^    int numflag = 0, wgtflag = 0, edgecut;$/;"	l
edges	irregular.h	/^		int *edges = (int *)edge_data;$/;"	l
edges_current	irregular/partitioner.cpp	/^			int edges_current = gpu_edge_vectors[j][i].size();		$/;"	l
edges_current	irregular/partitioner.cpp	/^		int edges_current = cpu_edge_vectors[i]->size();		$/;"	l
ek	moldyn.cu	/^ double ek, etot, temp, pres, rp, tscale ;$/;"	l
ekin	moldyn.cu	/^   double ekin, ts, sp, sc, r, s;$/;"	l
ekin	moldyn.cu	/^  double   ekin, percent;$/;"	l
element_t	regular/data_type.h	/^struct element_t$/;"	s
elm_size	lib/buffer.cpp	/^	int elm_size = elm_size_;		$/;"	l
elm_size	lib/buffer.h	/^	int elm_size() const{return elm_size_;}$/;"	f	class:Buffer
elm_size_	lib/buffer.h	/^	int elm_size_;$/;"	m	class:Buffer
end	irregular/cpu_kernel.cu	/^    	int end = ((task_index + CPU_BLOCK_SIZE - 1) > (number_edges - 1))?(number_edges-1):(start + CPU_BLOCK_SIZE-1);$/;"	l
end	irregular/data_type.h	/^	int end;$/;"	m	struct:part
end	irregular/gpu_kernel.cu	/^        	int end = parts[j].end;$/;"	l
end	irregular/partitioner.cpp	/^	T *end = coordinates + dim + num_dims * r; $/;"	l
end	irregular/reorder.cpp	/^	T *end = coordinates + dim + num_dims * r; $/;"	l
end	lib/compute_cpu.cpp	/^	int end = (tid + 1) * tiles_per_proc;$/;"	l
end	moldyn.cu	/^  int      start, end, how_often;$/;"	l
endl	km.cu	/^	cout<<"after start..."<<endl;$/;"	l
endl	km.cu	/^	cout<<"init done..."<<endl;$/;"	l
endl	km.cu	/^    	cout<<"Doing mapreduce..."<<endl;$/;"	l
endl	km.cu	/^    	cout<<"Load done..."<<endl;$/;"	l
endl	km.cu	/^    	cout<<"Load time: "<<(afterload-beforeload)<<endl<<endl;$/;"	l
endl	km.cu	/^    	cout<<"Loading data... "<<endl;$/;"	l
endl	km.cu	/^    	cout<<"The BSIZE is: "<<BSIZE<<endl;$/;"	l
endl	km.cu	/^    	cout<<"The first two integers are exhausted..."<<endl<<endl;$/;"	l
endl	km.cu	/^    	cout<<exhaust<<endl;$/;"	l
endl	lib/grid_view.cpp	/^		cout<<"my backward neighbors: "<<bw_neighbors<<endl;$/;"	l
endl	lib/grid_view.cpp	/^		cout<<"my forward neighbors: "<<fw_neighbors<<endl;$/;"	l
endl	lib/grid_view.cpp	/^		cout<<"my rank: "<<my_rank<<endl;$/;"	l
endl	lib/stencil_runtime.cu	/^		cout<<"#########along "<<i<<": "<<along_partitions_[i]<<endl;$/;"	l
endl	lib/stencil_runtime.cu	/^		cout<<"copying GPU: "<<i<<endl;$/;"	l
endl	lib/stencil_runtime.cu	/^	cout<<"################copy to cpu done..."<<endl;$/;"	l
endl	lib/stencil_runtime.cu	/^	cout<<"############internal size: "<<internal_size<<endl;$/;"	l
endl	lib/stencil_runtime.cu	/^	cout<<"#########along "<<(num_devices_ - 1)<<": "<<along_partitions_[num_devices_ - 1]<<endl;$/;"	l
endl	lib/stencil_runtime.cu	/^	cout<<"CPU thread launched..."<<endl;$/;"	l
endl	lib/stencil_runtime.cu	/^	cout<<"Rank: "<<my_rank_<<" Init done..."<<endl;$/;"	l
ep0	misc.c	/^    int i, lb, ub, ep0, ep1, localL, localR;$/;"	l
ep1	misc.c	/^    int i, lb, ub, ep0, ep1, localL, localR;$/;"	l
epot	moldyn.cu	/^double   epot,                  \/*  The potential energy      *\/$/;"	v
epot	moldyn.h	/^         epot,                  \/*  The potential energy      *\/$/;"	v
equal	irregular/hash.h	/^DEVICE bool equal(KEY *key1, KEY *key2)$/;"	f	namespace:FGPU
equal	regular/hash.h	/^DEVICE bool equal(void *key1, const unsigned short size1, void *key2, const unsigned short size2)$/;"	f	namespace:FFGPU
err	lib/cu_util.cu	/^        cudaError_t err = cudaGetLastError();$/;"	l
etot	moldyn.cu	/^ double ek, etot, temp, pres, rp, tscale ;$/;"	l
exchange	irregular/partitioner.cpp	/^void Partitioner::exchange(T *coordinates, int i, int j)$/;"	f	class:Partitioner
exchange	irregular/reorder.cpp	/^void Reorder::exchange(T *coordinates, int i, int j)$/;"	f	class:Reorder
exchange_halo_node_data	irregular/partition_view.cpp	/^void partition_view::exchange_halo_node_data(partition_mpi *p)$/;"	f	class:partition_view
exchange_halo_node_info	irregular/partition_view.cpp	/^void partition_view::exchange_halo_node_info()$/;"	f	class:partition_view
exchange_halo_size_info	irregular/partition_view.cpp	/^void partition_view::exchange_halo_size_info()$/;"	f	class:partition_view
exhaust	km.cu	/^    	int exhaust;$/;"	l
expanded	misc.c	/^    int *ind2, *taken, n_taken, *expanded, n_expanded, *from;$/;"	l
expanded	misc.c	/^    int *ind2, *taken, n_taken, *expanded, n_expanded;$/;"	l
f	misc.c	/^    double f0, f, f1, i0, i, i1;$/;"	l
f	misc.c	/^    int f;$/;"	l
f	moldyn.cu	/^double  f [NUM_PARTICLES][3];  \/* partial forces on each molecule    *\/$/;"	v
f	moldyn.cu	/^float  f [NUM_PARTICLES+4][3];  \/* partial forces on each molecule    *\/$/;"	v
f0	misc.c	/^    double f0, f, f1, i0, i, i1;$/;"	l
f1	misc.c	/^    double f0, f, f1, i0, i, i1;$/;"	l
filename	input/gen.c	/^  char   filename[30]; $/;"	l
filename	km.cu	/^    	char filename[] = "data";$/;"	l
filename1	moldyn.cu	/^  char     filename1[30], filename2[30];$/;"	l
filename2	input/gen.c	/^  char   filename2[30]; $/;"	l
filename2	moldyn.cu	/^  char     filename1[30], filename2[30];$/;"	l
find_neighbor_blk	input/gen.c	/^find_neighbor_blk(int x, int y, int z, int xd, int yd, int zd, int *neiblk) $/;"	f
find_neighbor_blk	moldyn.cu	/^find_neighbor_blk(int x, int y, int z, int xd, int yd, int zd, int *neiblk) $/;"	f
finer	metis.h	/^  struct graphdef *coarser, *finer;$/;"	m	struct:graphdef	typeref:struct:graphdef::
finish	irregular/roc.cu	/^	unsigned int finish = 0;$/;"	l
finish	irregular/rog.cu	/^	unsigned int finish = 0;$/;"	l
finish	irregular/ros.cu	/^	unsigned int finish = 0;$/;"	l
finish	regular/roc.cu	/^    bool finish = false; $/;"	l
finish	regular/rog.cu	/^	unsigned int finish = 0;$/;"	l
finish	regular/ros.cu	/^	unsigned int finish = 0;$/;"	l
finished	regular/gpu_kernel.cu	/^    __shared__ int finished;$/;"	l
first	lib/util.h	/^  bool first;$/;"	m	class:StringJoin
first	timer.c	/^static int first = 1;$/;"	v	file:
first_init	irregular/ros.cu	/^__device__ void Reduction_Object_S::first_init()$/;"	f	class:Reduction_Object_S
flag	regular/gpu_kernel.cu	/^        bool flag = true;$/;"	l
forces	irregular.h	/^		VALUE forces;$/;"	l
fp	input/gen.c	/^  FILE   *fp;$/;"	l
fpin	misc.c	/^    FILE *fpin;$/;"	l
fpin	misc.c	/^  FILE *fpin;$/;"	l
from	misc.c	/^     int n_nodes, n_edges, *partners, *from, n;$/;"	l
from	misc.c	/^    int  *partners, *from;$/;"	l
from	misc.c	/^    int  *sort_ord, *from2, *from, *ptnr2;$/;"	l
from	misc.c	/^    int *ind2, *taken, n_taken, *expanded, n_expanded, *from;$/;"	l
from	misc.c	/^    int *partners, *from;$/;"	l
from	misc.c	/^   int n_nodes, n_edges, *partners, *from, n, unit_sz, i, apply;$/;"	l
from2	misc.c	/^    int  *sort_ord, *from2, *from, *ptnr2;$/;"	l
from2	misc.c	/^    int  *sort_ord, *from2, *ptnr2;$/;"	l
full_from	misc.c	/^    int *full_partners, *full_from;$/;"	l
full_partners	misc.c	/^    int *full_partners, *full_from;$/;"	l
fw	lib/DS.h	/^  	UnsignedArray fw;$/;"	m	struct:Width2
fw_neighbors	lib/grid_view.h	/^	IndexArray fw_neighbors;$/;"	m	class:Grid_view
fw_peer	lib/grid_view.cpp	/^	int fw_peer = fw_neighbors[dim];$/;"	l
fw_peer	lib/grid_view.cpp	/^        	        << " bytes for fw access from " << fw_peer << "\\n";$/;"	l
fw_peer	lib/grid_view.cpp	/^        	        << " for bw access to " << fw_peer << "\\n";$/;"	l
fw_size	lib/grid_view.cpp	/^	size_t fw_size = grid->CalcHaloSize(dim, halo_fw_width) * grid->unit_size();$/;"	l
fx	moldyn.cu	112;"	d	file:
fx	moldyn.h	/^double  fx [NUM_PARTICLES],   \/* partial forces on each molecule    *\/$/;"	v
fy	moldyn.cu	113;"	d	file:
fy	moldyn.h	/^        fy [NUM_PARTICLES], $/;"	v
fz	moldyn.cu	114;"	d	file:
fz	moldyn.h	/^        fz [NUM_PARTICLES];$/;"	v
g	lib/grid.h	/^		Grid *g = new Grid(unit_size, num_dims, size);	$/;"	l
g	lib/grid_cpu.cpp	/^	GridCPU *g = new GridCPU(unit_size, num_dims, size, local_offset, local_size, halo, num_devices, device_id);	$/;"	l
g	lib/grid_cuda.cu	/^	GridCuda *g = new GridCuda(unit_size, num_dims, $/;"	l
g	lib/grid_mpi.cu	/^  GridMPI *g = new GridMPI($/;"	l
g	lib/grid_view.cpp	/^	GridMPI *g = GridMPI::Create(unit_size, num_dims, size, my_offset, my_size, halo); $/;"	l
g	lib/grid_view_cpu.cpp	/^	GridCPU *g = GridCPU::Create(elm_size, num_dims, my_size, my_offset, my_size, halo, num_devices, device_id); $/;"	l
g	lib/grid_view_cuda.cu	/^	GridCuda *g = GridCuda::Create(elm_size, num_dims, my_size, my_offset, my_size, halo, num_devices, device_id);$/;"	l
g	main.cpp	/^	GridMPI *g = sr->grid(); $/;"	l
g	main2.cpp	/^	GridMPI *g = gv.CreateGrid(sizeof(float), DIMS, global_size, 1);$/;"	l
gdata	metis.h	/^  idxtype *gdata, *rdata;	\/* Memory pools for graph and refinement data.$/;"	m	struct:graphdef
gen_part_index	irregular/partitioner.cpp	/^void Partitioner::gen_part_index()$/;"	f	class:Partitioner
gen_partition	regular/splitter.cpp	/^data_partition_mpi *splitter::gen_partition()$/;"	f	class:splitter
gen_rand	irregular/partitioner.cpp	/^int gen_rand(int p, int r)$/;"	f
gen_random	irregular/reorder.cpp	/^int gen_random(int p, int r)$/;"	f
generate_device_edges	irregular/partitioner.cpp	/^void Partitioner::generate_device_edges(EDGE *edges)$/;"	f	class:Partitioner
get	lib/util.h	/^  std::string get() const {$/;"	f	class:StringJoin
get	stencil.h	/^DEVICE size_t get(size_t reference, int dims, int *size, int i, int j, int k)$/;"	f	namespace:FGPU
get1DOffset	lib/compute_cpu.cpp	/^static size_t get1DOffset(const IndexArray &md_offset,$/;"	f	file:
get1DOffset	lib/data_util.cpp	/^static size_t get1DOffset(const IndexArray &md_offset,$/;"	f	file:
get1DOffset	lib/grid_util.cc	/^static size_t get1DOffset(const IndexArray &md_offset,$/;"	f	file:
get_address	regular/roc.cu	/^void *roc::get_address(unsigned index)$/;"	f	class:roc
get_compare_value	regular/rog.cu	/^__device__ int Reduction_Object_GPU::get_compare_value(unsigned int bucket_index1, unsigned int bucket_index2)$/;"	f	class:Reduction_Object_GPU
get_compare_value	regular/ros.cu	/^__device__ int Reduction_Object::get_compare_value(unsigned short bucket_index1, unsigned short bucket_index2)$/;"	f	class:Reduction_Object
get_cpu_edges	irregular/partitioner.cpp	/^EDGE *Partitioner::get_cpu_edges()$/;"	f	class:Partitioner
get_cpu_num_edges	irregular/partitioner.cpp	/^int Partitioner::get_cpu_num_edges()$/;"	f	class:Partitioner
get_cpu_num_parts	irregular/partitioner.cpp	/^int Partitioner::get_cpu_num_parts()$/;"	f	class:Partitioner
get_cpu_parts	irregular/partitioner.cpp	/^Part *Partitioner::get_cpu_parts()$/;"	f	class:Partitioner
get_device_id	irregular/partitioner.cpp	/^int Partitioner::get_device_id(size_t node_id)$/;"	f	class:Partitioner
get_gid	regular/gpu_kernel_tools.cu	/^__device__ unsigned int get_gid(int num_groups, int block_size, int tid)$/;"	f
get_gpu_edges	irregular/partitioner.cpp	/^EDGE **Partitioner::get_gpu_edges()$/;"	f	class:Partitioner
get_gpu_num_edges	irregular/partitioner.cpp	/^int *Partitioner::get_gpu_num_edges()$/;"	f	class:Partitioner
get_gpu_num_parts	irregular/partitioner.cpp	/^int *Partitioner::get_gpu_num_parts()$/;"	f	class:Partitioner
get_gpu_parts	irregular/partitioner.cpp	/^Part **Partitioner::get_gpu_parts()$/;"	f	class:Partitioner
get_group_id	regular/gpu_kernel_tools.cu	/^__device__ unsigned int get_group_id(int num_groups, int block_size, int tid)$/;"	f
get_group_size	regular/gpu_kernel_tools.cu	/^__device__ unsigned int get_group_size(int num_groups, int block_size, int group_id)$/;"	f
get_key_address	regular/roc.cu	/^void *roc::get_key_address(unsigned index)$/;"	f	class:roc
get_key_address	regular/rog.cu	/^__device__ void * Reduction_Object_GPU::get_key_address(unsigned int bucket_index)$/;"	f	class:Reduction_Object_GPU
get_key_address	regular/ros.cu	/^__device__ void * Reduction_Object::get_key_address(unsigned short bucket_index)$/;"	f	class:Reduction_Object
get_key_index	regular/ros.cu	/^__device__ unsigned short Reduction_Object::get_key_index(unsigned short bucket_index)$/;"	f	class:Reduction_Object
get_key_size	regular/roc.cu	/^unsigned roc::get_key_size(unsigned index)$/;"	f	class:roc
get_key_size	regular/rog.cu	/^__device__ unsigned short Reduction_Object_GPU::get_key_size(unsigned int bucket_index)$/;"	f	class:Reduction_Object_GPU
get_key_size	regular/ros.cu	/^__device__ unsigned short Reduction_Object::get_key_size(unsigned short bucket_index)$/;"	f	class:Reduction_Object
get_linear_offset	lib/buffer_cuda.cu	/^__device__ inline int get_linear_offset(size_t dim0,$/;"	f
get_linear_size	lib/compute_cuda.cu	/^__device__ int get_linear_size(int *size, int num_dims)$/;"	f
get_lock	irregular/cpu_kernel_tools.cu	/^	bool get_lock(volatile int *lock_value)$/;"	f
get_lock	irregular/gpu_kernel_tools.cu	/^	__device__ bool get_lock(int *lockVal)$/;"	f
get_lock	regular/gpu_kernel_tools.cu	/^__device__ bool get_lock(int *lockVal)$/;"	f
get_lock	regular/roc.cu	/^bool get_lock(volatile int *lock_value)$/;"	f
get_node_start	irregular/partitioner.cpp	/^int Partitioner::get_node_start(int device_id)$/;"	f	class:Partitioner
get_node_sum	irregular/partitioner.cpp	/^int Partitioner::get_node_sum(int device_id)$/;"	f	class:Partitioner
get_num_edges	irregular/reorder.cpp	/^int     Reorder::get_num_edges()$/;"	f	class:Reorder
get_num_groups	regular/gpu_kernel_tools.cu	/^__device__ unsigned int get_num_groups()$/;"	f
get_part_index	irregular/reorder.cpp	/^int * Reorder::get_part_index()$/;"	f	class:Reorder
get_partition_id	irregular/partitioner.cpp	/^int Partitioner::get_partition_id(size_t node_id, int device_id)$/;"	f	class:Partitioner
get_parts	irregular/reorder.cpp	/^Part * Reorder::get_parts()$/;"	f	class:Reorder
get_proc_id	irregular/partition_util.cpp	/^int get_proc_id(int node_id, int global_num_nodes, int num_procs)$/;"	f
get_rand_node	misc.c	/^get_rand_node (int n_nodes, int *taken)$/;"	f
get_reduction_result	irregular/irregular_runtime.cu	/^void IrregularRuntime::get_reduction_result(void *buffer)$/;"	f	class:IrregularRuntime
get_relative_cor	lib/compute_cuda.cu	/^__device__ void get_relative_cor(int *cor, int *tile_cor, int *size, int dim, int relative_number)$/;"	f
get_timer	timer.c	/^double get_timer()$/;"	f
get_timer_	timer.c	/^double get_timer_()$/;"	f
get_used_buckets	regular/ros.cu	/^__device__ inline void Reduction_Object::get_used_buckets(int *ret)$/;"	f	class:Reduction_Object
get_value_address	regular/roc.cu	/^void *roc::get_value_address(unsigned index)$/;"	f	class:roc
get_value_address	regular/rog.cu	/^__device__ void * Reduction_Object_GPU::get_value_address(unsigned int bucket_index)$/;"	f	class:Reduction_Object_GPU
get_value_address	regular/ros.cu	/^__device__ void * Reduction_Object::get_value_address(unsigned short bucket_index)$/;"	f	class:Reduction_Object
get_value_index	regular/ros.cu	/^__device__ unsigned short Reduction_Object::get_value_index(unsigned short bucket_index)$/;"	f	class:Reduction_Object
get_value_size	regular/roc.cu	/^unsigned roc::get_value_size(unsigned index)$/;"	f	class:roc
get_value_size	regular/rog.cu	/^__device__ unsigned short Reduction_Object_GPU::get_value_size(unsigned int bucket_index)$/;"	f	class:Reduction_Object_GPU
get_value_size	regular/ros.cu	/^__device__ unsigned short Reduction_Object::get_value_size(unsigned int bucket_index)$/;"	f	class:Reduction_Object
gid	regular/gpu_kernel.cu	/^    const int gid = get_gid(num_groups, GPU_THREADS, tid);$/;"	l
gid_g	regular/rog.cu	/^	unsigned int gid_g = tid\/WARP_SIZE;$/;"	l
global_edge_data_	irregular/irregular_runtime.h	/^	void *global_edge_data_;$/;"	m	class:IrregularRuntime
global_edge_data_	irregular/partition_view.h	/^	void *global_edge_data_;$/;"	m	class:partition_view
global_edges_	irregular/irregular_runtime.h	/^	EDGE *global_edges_;$/;"	m	class:IrregularRuntime
global_edges_	irregular/partition_view.h	/^	EDGE *global_edges_;$/;"	m	class:partition_view
global_halo_buf	lib/grid_cpu.cpp	/^	BufferHost *global_halo_buf = fw?grid_global->halo_peer_fw()[dim]:grid_global->halo_peer_bw()[dim];$/;"	l
global_halo_buf	lib/grid_cpu.cpp	/^	BufferHost *global_halo_buf = fw?grid_global->halo_self_fw()[dim]:grid_global->halo_self_bw()[dim];$/;"	l
global_halo_buf	lib/grid_cuda.cu	/^	char *global_halo_buf = (char *)(fw? grid_global->halo_self_fw()[dim]->Get() : grid_global->halo_self_bw()[dim]->Get());$/;"	l
global_halo_size	lib/grid_cuda.cu	/^	IndexArray global_halo_size = grid_global->my_real_size();$/;"	l
global_id	irregular/gpu_kernel.cu	/^    const unsigned int global_id = blockDim.x * blockIdx.x + tid;$/;"	l
global_id	irregular/reduction_array.h	/^	int *global_id(){return global_id_}$/;"	f	class:reduction_array
global_id	irregular/rog.cu	/^	const unsigned int global_id = blockDim.x * blockIdx.x + threadIdx.x;$/;"	l
global_id	irregular/rog.cu	/^	const unsigned int global_id = blockIdx.x * blockDim.x + threadIdx.x;$/;"	l
global_id	regular/gpu_kernel.cu	/^    const unsigned int global_id = blockDim.x * blockIdx.x + tid;$/;"	l
global_id	regular/rog.cu	/^		unsigned int global_id = bid * blockDim.x + tid;$/;"	l
global_id_	irregular/reduction_array.h	/^	int *global_id_;    \/\/indicates the position of each element in array_$/;"	m	class:reduction_array
global_linear_offset	lib/grid_cuda.cu	/^	size_t global_linear_offset = GridCalcOffset3D(global_offset, global_halo_size);$/;"	l
global_node_data_	irregular/irregular_runtime.h	/^	void *global_node_data_;$/;"	m	class:IrregularRuntime
global_node_data_	irregular/partition_view.h	/^	void *global_node_data_;$/;"	m	class:partition_view
global_num_edges_	irregular/irregular_runtime.h	/^	IRIndex global_num_edges_;$/;"	m	class:IrregularRuntime
global_num_edges_	irregular/partition_view.h	/^	IRIndex global_num_edges_;$/;"	m	class:partition_view
global_num_nodes_	irregular/irregular_runtime.h	/^	IRIndex  global_num_nodes_;$/;"	m	class:IrregularRuntime
global_num_nodes_	irregular/partition_view.h	/^	IRIndex global_num_nodes_;$/;"	m	class:partition_view
global_object_offset	regular/rog.cu	/^__shared__ unsigned int global_object_offset[GPU_THREADS\/WARP_SIZE];$/;"	v
global_real_size	lib/grid_cuda.cu	/^	IndexArray global_real_size = grid_global->my_real_size();$/;"	l
global_size	irregular/rog.cu	/^	const unsigned int global_size = gridDim.x * blockDim.x;$/;"	l
global_size	lib/compute_cuda.cu	/^		int global_size[3];$/;"	l
global_size	lib/grid_cuda.cu	/^	IndexArray global_size = grid_global->my_size();$/;"	l
global_size	lib/grid_view.h	/^	IndexArray global_size; \/\/for global data$/;"	m	class:Grid_view
global_size_	lib/stencil_creator.h	/^	IndexArray global_size_;$/;"	m	class:StencilCreator
global_size_	lib/stencil_runtime.h	/^	IndexArray global_size_;$/;"	m	class:StencilRuntime
gpart_m	misc.c	/^static double gpart_time, gpart_ovrhd, gpart_m;$/;"	v	file:
gpart_ovrhd	misc.c	/^static double gpart_time, gpart_ovrhd, gpart_m;$/;"	v	file:
gpart_time	misc.c	/^static double gpart_time, gpart_ovrhd, gpart_m;$/;"	v	file:
gpartprocess	misc.c	/^gpartprocess(int n_nodes, int n_edges, int (*el)[2], int n, long (*repos)[2])$/;"	f
gpartprocess2	misc.c	/^gpartprocess2(int n_nodes, int n_edges, int *partners, int *from, int n, long (*repos)[2])$/;"	f
gpuAssert	lib/cu_util.h	/^inline void gpuAssert(cudaError_t code, char *file, int line, bool abort=true)$/;"	f
gpu_args_reg	regular/args.h	/^struct gpu_args_reg$/;"	s
gpu_edge_vectors	irregular/partitioner.h	/^	vector<struct edge> **gpu_edge_vectors;$/;"	m	class:Partitioner
gpu_edges	irregular/partitioner.h	/^	EDGE **gpu_edges;$/;"	m	class:Partitioner
gpu_id	lib/grid_cuda.cu	/^		int gpu_id = device_id_ - 1;$/;"	l
gpu_id	lib/grid_cuda.cu	/^	int gpu_id = device_id_ - 1;$/;"	l
gpu_id	regular/args.h	/^	int gpu_id;$/;"	m	struct:gpu_args_reg
gpu_new_edges	irregular/partitioner.h	/^	int *gpu_new_edges;$/;"	m	class:Partitioner
gpu_nodes_per_partition	irregular/partitioner.h	/^	int gpu_nodes_per_partition;$/;"	m	class:Partitioner
gpu_partition	irregular/partitioner.h	/^	int *gpu_partition;$/;"	m	struct:partition_args
gpu_partitions	irregular/partitioner.h	/^	int **gpu_partitions;$/;"	m	class:Partitioner
gpu_parts	irregular/partitioner.h	/^	Part **gpu_parts;$/;"	m	class:Partitioner
gpu_total_edges	irregular/partitioner.cpp	/^	int *gpu_total_edges = get_gpu_num_edges();$/;"	l
gpu_total_num_nodes_	irregular/partitioner.h	/^	int *gpu_total_num_nodes_;$/;"	m	class:Partitioner
gpu_total_num_partitions_	irregular/partitioner.h	/^	int *gpu_total_num_partitions_;$/;"	m	class:Partitioner
graph	misc.c	/^    GraphType graph;$/;"	l
graphdef	metis.h	/^struct graphdef {$/;"	s
grid	irregular/irregular_runtime.cu	/^		compute_gpu<<<grid, block, 0>>>$/;"	l
grid	irregular/irregular_runtime.cu	/^		init_rog<<<grid, block>>>(rog_[i]);$/;"	l
grid	lib/buffer_cuda.cu	/^		copy_halo_3D<double><<<grid, block, 0, stream>>>$/;"	l
grid	lib/buffer_cuda.cu	/^		copy_halo_3D<float><<<grid, block, 0, stream>>>$/;"	l
grid	lib/compute_cpu.cpp	/^	GridMPI *grid = runtime->grid_cpu();$/;"	l
grid	lib/grid_view.cpp	/^    		cout << "grid: " << grid << "\\n";$/;"	l
grid	lib/stencil_runtime.cu	/^		compute_cuda_internal<<<grid, block, 0>>>$/;"	l
grid	lib/stencil_runtime.h	/^	GridMPI *grid(){return grid_;}$/;"	f	class:StencilRuntime
grid	regular/regular_runtime.cu	/^			compute_gpu<<<grid, block>>>$/;"	l
grid_	lib/stencil_runtime.cu	/^	delete grid_;$/;"	l
grid_	lib/stencil_runtime.h	/^	GridMPI *grid_;$/;"	m	class:StencilRuntime
grid_1d_offset	lib/data_util.cpp	/^			size_t grid_1d_offset =$/;"	l
grid_1d_offset	lib/grid_util.cc	/^      size_t grid_1d_offset =$/;"	l
grid_cpu	lib/stencil_runtime.h	/^	GridCPU *grid_cpu(){return grid_cpu_;}$/;"	f	class:StencilRuntime
grid_cpu_	lib/stencil_runtime.cu	/^	delete grid_cpu_;$/;"	l
grid_cpu_	lib/stencil_runtime.h	/^	GridCPU *grid_cpu_; 	\/\/the part for cpu processing$/;"	m	class:StencilRuntime
grid_cpu_	main1.cpp	/^	GridCPU *grid_cpu_ = gv_cpu_->CreateGrid(1, 3, offset, offset, 6, 1, 0);$/;"	l
grid_cuda	lib/stencil_runtime.h	/^	GridCuda *grid_cuda(int id){return grid_cuda_[id];}$/;"	f	class:StencilRuntime
grid_cuda_	lib/stencil_runtime.cu	/^		delete grid_cuda_[i];		$/;"	l
grid_cuda_	lib/stencil_runtime.h	/^	GridCuda **grid_cuda_; 	\/\/cuda grids$/;"	m	class:StencilRuntime
grid_size	lib/data_util.cpp	/^              << "grid size: " << grid_size$/;"	l
grid_size	lib/grid_util.cc	/^              << "grid size: " << grid_size$/;"	l
group_id	regular/gpu_kernel.cu	/^	        merge(object_g, (SO *)object_s + group_id); $/;"	l
group_id	regular/gpu_kernel.cu	/^    const int group_id = get_group_id(num_groups, GPU_THREADS, tid);$/;"	l
group_size	regular/gpu_kernel.cu	/^    const int group_size = get_group_size(num_groups, GPU_THREADS, group_id);$/;"	l
group_size	regular/ros.cu	/^	const unsigned int group_size = blockDim.x\/NUM_GROUPS;$/;"	l
gv	lib/stencil_runtime.h	/^	Grid_view *gv(){return gv_;}$/;"	f	class:StencilRuntime
gv	metis.h	/^  idxtype gv;$/;"	m	struct:vedegreedef
gv	metis.h	/^ int gv;            		\/* IV\/EV of nodes *\/$/;"	m	struct:vrinfodef
gv_	lib/stencil_runtime.cu	/^	delete gv_;	$/;"	l
gv_	lib/stencil_runtime.h	/^	Grid_view *gv_;$/;"	m	class:StencilRuntime
gv_cpu_	lib/stencil_runtime.cu	/^	delete gv_cpu_;$/;"	l
gv_cpu_	lib/stencil_runtime.h	/^	Grid_view_cpu *gv_cpu_;$/;"	m	class:StencilRuntime
gv_cpu_	main1.cpp	/^	Grid_view_cpu *gv_cpu_ = new Grid_view_cpu();	$/;"	l
gv_cuda_	lib/stencil_runtime.cu	/^		delete gv_cuda_[i];$/;"	l
gv_cuda_	lib/stencil_runtime.h	/^	Grid_view_cuda **gv_cuda_;$/;"	m	class:StencilRuntime
gx	Session.vim	/^nmap gx <Plug>NetrwBrowseX$/;"	m
gx	input/Session.vim	/^nmap gx <Plug>NetrwBrowseX$/;"	m
gx	lib/Session.vim	/^nmap gx <Plug>NetrwBrowseX$/;"	m
h	irregular/roc.cu	/^	unsigned int h = FCPU::hash(key);$/;"	l
h	irregular/rog.cu	/^	unsigned int h = FGPU::hash(key);$/;"	l
h	irregular/ros.cu	/^	unsigned int h = FGPU::hash(key);$/;"	l
h	regular/roc.cu	/^    int h = FFCPU::hash(key, key_size); $/;"	l
h	regular/rog.cu	/^	unsigned int h = FFGPU::hash(key, key_size);	$/;"	l
h	regular/ros.cu	/^	unsigned int h = FFGPU::hash(key, key_size);	$/;"	l
halo	lib/grid_mpi.h	/^  	Width2 &halo() { return halo_; }$/;"	f	class:GridMPI
halo	lib/grid_view.cpp	/^	Width2 halo = {halo_bw, halo_fw};$/;"	l
halo	lib/grid_view_cpu.cpp	/^	Width2 halo = {halo_bw, halo_fw};$/;"	l
halo	lib/grid_view_cuda.cu	/^	Width2 halo = {halo_bw, halo_fw};$/;"	l
halo_	lib/grid_mpi.h	/^	Width2 halo_;$/;"	m	class:GridMPI
halo_buf	lib/grid_cuda.cu	/^	BufferCUDAHost *halo_buf = fw ? halo_peer_fw()[dim] : halo_peer_bw()[dim];$/;"	l
halo_buf	lib/grid_cuda.cu	/^	BufferCUDAHost *halo_buf = fw ? halo_self_fw()[dim] : halo_self_bw()[dim];	$/;"	l
halo_buf	lib/grid_mpi.cu	/^  	char *halo_buf = (char *)((fw ? halo_peer_fw_[dim] : halo_peer_bw_[dim])->Get());$/;"	l
halo_bw	lib/grid_view.cpp	/^	IndexArray halo_bw;$/;"	l
halo_bw	lib/grid_view_cpu.cpp	/^	IndexArray halo_bw;$/;"	l
halo_bw	lib/grid_view_cuda.cu	/^	IndexArray halo_bw;$/;"	l
halo_fw	lib/grid_view.cpp	/^	IndexArray halo_fw;				$/;"	l
halo_fw	lib/grid_view_cpu.cpp	/^	IndexArray halo_fw;				$/;"	l
halo_fw	lib/grid_view_cuda.cu	/^	IndexArray halo_fw;$/;"	l
halo_peer_bw	lib/grid_cuda.h	/^	BufferCUDAHost **halo_peer_bw(){return halo_peer_bw_;}$/;"	f	class:GridCuda
halo_peer_bw	lib/grid_mpi.h	/^	BufferHost **halo_peer_bw(){return halo_peer_bw_;}$/;"	f	class:GridMPI
halo_peer_bw	lib/test/test_util.h	/^  T **halo_peer_bw = (T**)g->halo_peer_bw();$/;"	l
halo_peer_bw_	lib/grid_cuda.h	/^	BufferCUDAHost **halo_peer_bw_;$/;"	m	class:GridCuda
halo_peer_bw_	lib/grid_mpi.h	/^	BufferHost **halo_peer_bw_;$/;"	m	class:GridMPI
halo_peer_fw	lib/grid_cuda.h	/^	BufferCUDAHost **halo_peer_fw(){return halo_peer_fw_;}$/;"	f	class:GridCuda
halo_peer_fw	lib/grid_mpi.h	/^	BufferHost **halo_peer_fw(){return halo_peer_fw_;}$/;"	f	class:GridMPI
halo_peer_fw	lib/test/test_util.h	/^  T **halo_peer_fw = (T**)g->halo_peer_fw();$/;"	l
halo_peer_fw_	lib/grid_cuda.h	/^	BufferCUDAHost **halo_peer_fw_;$/;"	m	class:GridCuda
halo_peer_fw_	lib/grid_mpi.h	/^	BufferHost **halo_peer_fw_;$/;"	m	class:GridMPI
halo_self_bw	lib/grid_cuda.h	/^	BufferCUDAHost **halo_self_bw(){return halo_self_bw_;}$/;"	f	class:GridCuda
halo_self_bw	lib/grid_mpi.h	/^	BufferHost **halo_self_bw(){return halo_self_bw_;}$/;"	f	class:GridMPI
halo_self_bw	lib/test/test_util.h	/^  T **halo_self_bw = (T**)g->halo_self_bw();$/;"	l
halo_self_bw_	lib/grid_cuda.h	/^	BufferCUDAHost **halo_self_bw_;$/;"	m	class:GridCuda
halo_self_bw_	lib/grid_mpi.h	/^	BufferHost **halo_self_bw_;$/;"	m	class:GridMPI
halo_self_fw	lib/grid_cuda.h	/^	BufferCUDAHost **halo_self_fw(){return halo_self_fw_;}$/;"	f	class:GridCuda
halo_self_fw	lib/grid_mpi.h	/^	BufferHost **halo_self_fw(){return halo_self_fw_;}$/;"	f	class:GridMPI
halo_self_fw	lib/test/test_util.h	/^  T **halo_self_fw = (T**)g->halo_self_fw();$/;"	l
halo_self_fw_	lib/grid_cuda.h	/^	BufferCUDAHost **halo_self_fw_;$/;"	m	class:GridCuda
halo_self_fw_	lib/grid_mpi.h	/^	BufferHost **halo_self_fw_;$/;"	m	class:GridMPI
halo_size	lib/grid_cuda.cu	/^	IndexArray halo_size = my_size();$/;"	l
halo_size	lib/grid_mpi.cu	/^  	IndexArray halo_size = my_real_size_;$/;"	l
halo_size	lib/grid_mpi.cu	/^  IndexArray halo_size = my_real_size_;$/;"	l
has_taskl	irregular/gpu_kernel.cu	/^    __shared__ int has_taskl;$/;"	l
has_taskl	regular/gpu_kernel.cu	/^    __shared__ int has_taskl;$/;"	l
hash	irregular/hash.h	/^DEVICE unsigned int hash(KEY *key)$/;"	f	namespace:FGPU
hash	regular/hash.h	/^DEVICE unsigned int hash(void *key, unsigned short size)$/;"	f	namespace:FFGPU
hcnt	misc.c	/^    int  i, max_degree, *hcnt;$/;"	l
heap	metis.h	/^  KeyValueType *heap;$/;"	m	struct:PQueueType
how_often	moldyn.cu	/^  int      start, end, how_often;$/;"	l
i	input/gen.c	/^    int i, j, k, l, m, ii, jj, n_blk;$/;"	l
i	input/gen.c	/^    int i, j, k, n = 0; $/;"	l
i	input/gen.c	/^    int i, p1, p2, cut_edge = 0;$/;"	l
i	input/gen.c	/^   int i, a, b, n= numMoles; $/;"	l
i	input/gen.c	/^  int    i, j, prev;$/;"	l
i	input/gen.c	/^ int n, k,  j, i, npoints;$/;"	l
i	irregular.h	/^		int i, j;$/;"	l
i	irregular/partitioner.cpp	/^	int i =  gen_rand(p, r);	$/;"	l
i	irregular/partitioner.cpp	/^	int i = p - 1;$/;"	l
i	irregular/reorder.cpp	/^	int i =  gen_random(p, r);	$/;"	l
i	irregular/reorder.cpp	/^	int i = p - 1;$/;"	l
i	lib/array.h	/^      sj << *i;$/;"	l
i	lib/array.h	/^  FOREACH (i, x.begin(), x.end()) { sj << *i; }$/;"	l
i	misc.c	/^	static int i=0, ipercent;$/;"	l	file:
i	misc.c	/^        static int i=0, ipercent;$/;"	l	file:
i	misc.c	/^     int i, j, k, ntimes, r1, r2, *ind2, *p;$/;"	l
i	misc.c	/^     int i, ntimes, r1, r2, *ind=NULL, *ind2=NULL, *p;$/;"	l
i	misc.c	/^    double f0, f, f1, i0, i, i1;$/;"	l
i	misc.c	/^    int  i, j, k, p, n = 0;$/;"	l
i	misc.c	/^    int  i, j, k, p, q, n = 0;$/;"	l
i	misc.c	/^    int  i, j, k, t, n_pieces, root, root2, p, done, iter, real_i;$/;"	l
i	misc.c	/^    int  i, max_degree, *hcnt;$/;"	l
i	misc.c	/^    int *ind, i, siz, siz0 = 0; $/;"	l
i	misc.c	/^    int a, i, j; $/;"	l
i	misc.c	/^    int i, *count, *count2, *tmp, *tmp2, *p;$/;"	l
i	misc.c	/^    int i, j, *n;                            	$/;"	l
i	misc.c	/^    int i, j, k, *last_app, n_reuse; $/;"	l
i	misc.c	/^    int i, j, k, a, npart;$/;"	l
i	misc.c	/^    int i, j, k, degree, max, root=0, p, cur, last, reverse = 1;$/;"	l
i	misc.c	/^    int i, j, k, n_blk, n_x, n_y, n_z, n_th;$/;"	l
i	misc.c	/^    int i, j, k;$/;"	l
i	misc.c	/^    int i, j;$/;"	l
i	misc.c	/^    int i, lb, ub, ep0, ep1, localL, localR;$/;"	l
i	misc.c	/^    int i, p, lb, ub, pt, bp, ip, jp, localI, localP;$/;"	l
i	misc.c	/^    int i,j, begin, cur;$/;"	l
i	misc.c	/^    int i;$/;"	l
i	misc.c	/^    int levels, i,j,k;$/;"	l
i	misc.c	/^   int n_nodes, n_edges, (*el)[2], n, unit_sz, i, apply;$/;"	l
i	misc.c	/^   int n_nodes, n_edges, *partners, *from, n, unit_sz, i, apply;$/;"	l
i	misc.c	/^  int i, k, cnt, edge;$/;"	l
i	misc.c	/^  int i, k, edge;$/;"	l
i	misc.c	/^  int i;$/;"	l
i	moldyn.cu	/^	   int i, j;$/;"	l
i	moldyn.cu	/^    int i, j, k, l, m, ii, jj, n_blk;$/;"	l
i	moldyn.cu	/^    int i, j, k, n = 0; $/;"	l
i	moldyn.cu	/^   int i, j, iseed, n_moles;$/;"	l
i	moldyn.cu	/^   int i, org_neighUpdate;$/;"	l
i	moldyn.cu	/^  int      tmp,procs,i,j,k,ii, start_time;$/;"	l
i	moldyn.cu	/^ int n, k,  j, i, npoints;$/;"	l
i	moldyn.cu	/^int i, n_moles;$/;"	l
i	regular/gpu_kernel.cu	/^        int i = tid;$/;"	l
i	stencil.h	/^	int i = offset[2];	$/;"	l
i0	misc.c	/^    double f0, f, f1, i0, i, i1;$/;"	l
i1	misc.c	/^    double f0, f, f1, i0, i, i1;$/;"	l
id	metis.h	/^  idxtype *id, *ed;$/;"	m	struct:graphdef
id	metis.h	/^  int id;                       	\/* The id value of the node *\/$/;"	m	struct:ListNodeType
id	metis.h	/^ int id, ed, nid;            	\/* ID\/ED of nodes *\/$/;"	m	struct:vrinfodef
id	metis.h	/^ int id, ed;            	\/* ID\/ED of nodes *\/$/;"	m	struct:rinfodef
id	regular/rog.cu	/^	const unsigned int id = bid*blockDim.x+tid;$/;"	l
id	regular/ros.cu	/^	const unsigned int id = tid%group_size; \/\/the id in one group$/;"	l
id	regular/ros.cu	/^	const unsigned int id = tid%group_size;$/;"	l
idx	lib/grid_view.cpp	/^		IndexArray idx;	$/;"	l
idx	main.cpp	/^  int idx = 0;$/;"	l
idx	main2.cpp	/^  int idx = 0;$/;"	l
idx	misc.c	/^    int *idx, *tmp2;$/;"	l
idx0	irregular/data_type.h	/^	int idx0;	$/;"	m	struct:edge
idx0	irregular/partition_view.cpp	/^		int idx0 = tmp.idx0;$/;"	l
idx0	irregular/partition_view.cpp	/^	int idx0, idx1, proc0, proc1;$/;"	l
idx1	irregular/data_type.h	/^	int idx1;$/;"	m	struct:edge
idx1	irregular/partition_view.cpp	/^		int idx1 = tmp.idx1;$/;"	l
idx1	irregular/partition_view.cpp	/^	int idx0, idx1, proc0, proc1;$/;"	l
idxtype	metis.h	/^typedef int idxtype;$/;"	t
idxtype	metis.h	/^typedef short idxtype;$/;"	t
ii	input/gen.c	/^    int i, j, k, l, m, ii, jj, n_blk;$/;"	l
ii	misc.c	/^    int ii, jj;$/;"	l
ii	moldyn.cu	/^    int i, j, k, l, m, ii, jj, n_blk;$/;"	l
ii	moldyn.cu	/^  int      tmp,procs,i,j,k,ii, start_time;$/;"	l
imax	metis.h	/^  int imax[2][MAXNCON];$/;"	m	struct:vpwgtdef
incoming_reduction_array	irregular/reduction_array.h	/^class incoming_reduction_array:public reduction_array$/;"	c
ind	misc.c	/^     int *t_from, *t_ptnr, *ind;$/;"	l
ind	misc.c	/^     int i, ntimes, r1, r2, *ind=NULL, *ind2=NULL, *p;$/;"	l
ind	misc.c	/^    int *ind, i, siz, siz0 = 0; $/;"	l
ind2	misc.c	/^     int i, j, k, ntimes, r1, r2, *ind2, *p;$/;"	l
ind2	misc.c	/^     int i, ntimes, r1, r2, *ind=NULL, *ind2=NULL, *p;$/;"	l
ind2	misc.c	/^    int  *nodes, *degree, *cnt, *ind2, *nodes2, *tp;$/;"	l
ind2	misc.c	/^    int  *taken, *ind2;$/;"	l
ind2	misc.c	/^    int *cnt, *ind2;$/;"	l
ind2	misc.c	/^    int *ind2, *taken, n_taken, *expanded, n_expanded, *from;$/;"	l
ind2	misc.c	/^    int *ind2, *taken, n_taken, *expanded, n_expanded;$/;"	l
ind2	misc.c	/^    int npart, *part, *ind2;		\/* beginning of a part *\/$/;"	l
index	irregular/roc.cu	/^	unsigned int index = h%NUM_BUCKETS_G;$/;"	l
index	irregular/rog.cu	/^	unsigned int index = h%NUM_BUCKETS_G;$/;"	l
index	irregular/ros.cu	/^	unsigned int index = h%NUM_BUCKETS_S;$/;"	l
index	moldyn.cu	/^		    int index = ninter++;$/;"	l
index	regular/roc.cu	/^    int index = h%NUM_BUCKETS_G;$/;"	l
index	regular/rog.cu	/^	unsigned int index = h%NUM_BUCKETS_G;$/;"	l
index	regular/ros.cu	/^	unsigned int index = h%NUM_BUCKETS_S;$/;"	l
index_map	irregular/partitioner.h	/^	int *index_map; \/\/used to record the change of position of points$/;"	m	class:Partitioner
index_map	irregular/reorder.h	/^	int *index_map; \/\/used to record the change of position of points$/;"	m	class:Reorder
init	irregular/roc.cu	/^void Reduction_Object_C::init(int tid)$/;"	f	class:Reduction_Object_C
init	irregular/rog.cu	/^__device__ void Reduction_Object_G::init()$/;"	f	class:Reduction_Object_G
init	irregular/ros.cu	/^__device__ void Reduction_Object_S::init()$/;"	f	class:Reduction_Object_S
init_args	irregular/cpu_args.h	/^struct init_args$/;"	s
init_args	irregular/irregular_runtime.cu	/^	struct init_args init_args[CPU_THREADS];$/;"	l
init_grid	main.cpp	/^static void init_grid(GridMPI *g, int my_rank) {$/;"	f	file:
init_grid	main2.cpp	/^static void init_grid(GridMPI *g, int my_rank) {$/;"	f	file:
init_max_part	misc.c	/^    int  max_degree, init_max_part, cur_max_part, m, max;$/;"	l
init_pSize	misc.c	/^int init_pSize = 4;$/;"	v
init_roc	irregular/cpu_kernel.cu	/^void *init_roc(void *arg)$/;"	f
init_rog	irregular/gpu_kernel.cu	/^__global__ void init_rog(Gobject *gobject)$/;"	f
init_time	moldyn.cu	/^  double   init_time, prev_time = 0.0, tmp_time, update_time = 0.0;$/;"	l
init_val	irregular/irregular_runtime.cu	/^		int init_val = 0;$/;"	l
init_val	irregular/irregular_runtime.cu	/^	int init_val = 0;$/;"	l
initial_size	lib/data_util.cpp	/^    		PSIndex initial_size;$/;"	l
initial_size	lib/grid_util.cc	/^    PSIndex initial_size;$/;"	l
input	irregular.h	/^		struct point_data *input = (struct point_data *)point_data;$/;"	l
input	km.cu	/^    	ifstream input;$/;"	l
input	lib/compute_cpu.cpp	/^	char *input = grid->data_in();$/;"	l
input	regular/cpu_kernel.cu	/^    void *input = runtime->input_pin_;$/;"	l
input	regular/data_partition_mpi.h	/^	void *input(){return input_;}$/;"	f	class:data_partition_mpi
input	regular/regular_runtime.cu	/^	void *input = input_pin_;$/;"	l
input_	regular/data_partition_mpi.h	/^	void *input_;	$/;"	m	class:data_partition_mpi
input_	regular/regular_runtime.h	/^	void *input_;$/;"	m	class:RegularRuntime
input_	regular/splitter.h	/^		void *input_;$/;"	m	class:splitter
input_buffer_d_	regular/regular_runtime.h	/^	void **input_buffer_d_;	$/;"	m	class:RegularRuntime
input_end	regular/regular_runtime.cu	/^			int input_end[2];$/;"	l
input_pin	regular/data_partition_mpi.h	/^	void *input_pin(){return input_pin_;}$/;"	f	class:data_partition_mpi
input_pin_	regular/data_partition_mpi.h	/^	void *input_pin_;$/;"	m	class:data_partition_mpi
input_pin_	regular/regular_runtime.h	/^	void *input_pin_;$/;"	m	class:RegularRuntime
input_size	regular/data_partition_mpi.h	/^	int input_size(){return input_size_;}$/;"	f	class:data_partition_mpi
input_size	regular/regular_runtime.cu	/^			int input_size[2];$/;"	l
input_size_	regular/data_partition_mpi.h	/^	int input_size_;$/;"	m	class:data_partition_mpi
input_size_	regular/regular_runtime.h	/^	int input_size_;$/;"	m	class:RegularRuntime
input_size_	regular/splitter.h	/^		int input_size_;$/;"	m	class:splitter
input_start	regular/regular_runtime.cu	/^			int input_start[2];$/;"	l
insert	irregular/roc.cu	/^bool Reduction_Object_C::insert(KEY *key, VALUE *value)$/;"	f	class:Reduction_Object_C
insert	irregular/rog.cu	/^__device__ bool Reduction_Object_G::insert(KEY *key, VALUE *value)$/;"	f	class:Reduction_Object_G
insert	irregular/ros.cu	/^__device__ bool Reduction_Object_S::insert(KEY *key, VALUE *value)$/;"	f	class:Reduction_Object_S
insert	regular/roc.cu	/^bool roc::insert(void *key, unsigned key_size, void *value, unsigned value_size)$/;"	f	class:roc
insert	regular/rog.cu	/^__device__ bool Reduction_Object_GPU::insert(void *key, unsigned short key_size, void *value, unsigned short value_size)$/;"	f	class:Reduction_Object_GPU
insert	regular/ros.cu	/^__device__ bool Reduction_Object::insert(void *key, unsigned short key_size, void *value, unsigned short value_size)$/;"	f	class:Reduction_Object
inspector	misc.c	/^inspector(int (*el)[2], int ne, int nn, int my_id, int nproc,$/;"	f
inspector2	misc.c	/^inspector2(int *ptnr, int *from, int nn, int my_id, int nproc,$/;"	f
inter	input/gen.c	/^int     inter [MAXINTERACT][2]; \/* (inter1, inter2) interacting pairs *\/$/;"	v
inter	moldyn.cu	/^int     inter [MAXINTERACT][2]; $/;"	v
inter1	input/gen.c	25;"	d	file:
inter1	moldyn.cu	117;"	d	file:
inter1	moldyn.h	/^EXTERN int     *inter1, *inter2;$/;"	v
inter2	input/gen.c	26;"	d	file:
inter2	moldyn.cu	118;"	d	file:
inter2	moldyn.h	/^EXTERN int     *inter1, *inter2;$/;"	v
interdevice_exchange	lib/stencil_runtime.cu	/^void StencilRuntime::interdevice_exchange()$/;"	f	class:StencilRuntime
internal_size	lib/stencil_runtime.cu	/^		IndexArray internal_size;$/;"	l
internal_size	lib/stencil_runtime.cu	/^		tiling(num_dims(), internal_size, internal_start, GPU_TILE_SIZE, internal_tiles[j + 1]);$/;"	l
internal_size	lib/stencil_runtime.cu	/^	IndexArray internal_size;$/;"	l
internal_start	lib/stencil_runtime.cu	/^		IndexArray internal_start;   	$/;"	l
internal_start	lib/stencil_runtime.cu	/^		tiling(num_dims(), internal_size, internal_start, GPU_TILE_SIZE, internal_tiles[j + 1]);$/;"	l
internal_start	lib/stencil_runtime.cu	/^	IndexArray internal_start;   	$/;"	l
internal_tiles	lib/stencil_runtime.cu	/^		tiling(num_dims(), internal_size, internal_start, GPU_TILE_SIZE, internal_tiles[j + 1]);$/;"	l
internal_tiles	lib/stencil_runtime.h	/^	vector<struct Tile> *internal_tiles;$/;"	m	class:StencilRuntime
intl	regular/roc.h	/^struct intl$/;"	s
ip	misc.c	/^    int i, p, lb, ub, pt, bp, ip, jp, localI, localP;$/;"	l
ipercent	misc.c	/^	static int i=0, ipercent;$/;"	l	file:
ipercent	misc.c	/^        static int i=0, ipercent;$/;"	l	file:
iseed	moldyn.cu	/^   int i, j, iseed, n_moles;$/;"	l
iter	misc.c	/^    int  i, j, k, t, n_pieces, root, root2, p, done, iter, real_i;$/;"	l
ixj	regular/rog.cu	/^	const unsigned int ixj = id ^ j;\/\/j controls which thread to use $/;"	l
ixj	regular/ros.cu	/^			unsigned int ixj = id ^ j;	$/;"	l
j	input/gen.c	/^    int i, j, k, l, m, ii, jj, n_blk;$/;"	l
j	input/gen.c	/^    int i, j, k, n = 0; $/;"	l
j	input/gen.c	/^  int    i, j, prev;$/;"	l
j	input/gen.c	/^ int n, k,  j, i, npoints;$/;"	l
j	irregular.h	/^		int i, j;$/;"	l
j	misc.c	/^     int i, j, k, ntimes, r1, r2, *ind2, *p;$/;"	l
j	misc.c	/^    int  i, j, k, p, n = 0;$/;"	l
j	misc.c	/^    int  i, j, k, p, q, n = 0;$/;"	l
j	misc.c	/^    int  i, j, k, t, n_pieces, root, root2, p, done, iter, real_i;$/;"	l
j	misc.c	/^    int a, i, j; $/;"	l
j	misc.c	/^    int i, j, *n;                            	$/;"	l
j	misc.c	/^    int i, j, k, *last_app, n_reuse; $/;"	l
j	misc.c	/^    int i, j, k, a, npart;$/;"	l
j	misc.c	/^    int i, j, k, degree, max, root=0, p, cur, last, reverse = 1;$/;"	l
j	misc.c	/^    int i, j, k, n_blk, n_x, n_y, n_z, n_th;$/;"	l
j	misc.c	/^    int i, j, k;$/;"	l
j	misc.c	/^    int i, j;$/;"	l
j	misc.c	/^    int i,j, begin, cur;$/;"	l
j	misc.c	/^    int levels, i,j,k;$/;"	l
j	moldyn.cu	/^	   int i, j;$/;"	l
j	moldyn.cu	/^    int i, j, k, l, m, ii, jj, n_blk;$/;"	l
j	moldyn.cu	/^    int i, j, k, n = 0; $/;"	l
j	moldyn.cu	/^   int i, j, iseed, n_moles;$/;"	l
j	moldyn.cu	/^  int      tmp,procs,i,j,k,ii, start_time;$/;"	l
j	moldyn.cu	/^ int n, k,  j, i, npoints;$/;"	l
j	stencil.h	/^	int j = offset[1];	$/;"	l
jj	input/gen.c	/^    int i, j, k, l, m, ii, jj, n_blk;$/;"	l
jj	misc.c	/^    int ii, jj;$/;"	l
jj	moldyn.cu	/^    int i, j, k, l, m, ii, jj, n_blk;$/;"	l
jp	misc.c	/^    int i, p, lb, ub, pt, bp, ip, jp, localI, localP;$/;"	l
k	input/gen.c	/^    int i, j, k, l, m, ii, jj, n_blk;$/;"	l
k	input/gen.c	/^    int i, j, k, n = 0; $/;"	l
k	input/gen.c	/^ int n, k,  j, i, npoints;$/;"	l
k	irregular/partitioner.cpp	/^	int k = q - p + 1;$/;"	l
k	irregular/reorder.cpp	/^	int k = q - p + 1;$/;"	l
k	misc.c	/^     int i, j, k, ntimes, r1, r2, *ind2, *p;$/;"	l
k	misc.c	/^    int  i, j, k, p, n = 0;$/;"	l
k	misc.c	/^    int  i, j, k, p, q, n = 0;$/;"	l
k	misc.c	/^    int  i, j, k, t, n_pieces, root, root2, p, done, iter, real_i;$/;"	l
k	misc.c	/^    int i, j, k, *last_app, n_reuse; $/;"	l
k	misc.c	/^    int i, j, k, a, npart;$/;"	l
k	misc.c	/^    int i, j, k, degree, max, root=0, p, cur, last, reverse = 1;$/;"	l
k	misc.c	/^    int i, j, k, n_blk, n_x, n_y, n_z, n_th;$/;"	l
k	misc.c	/^    int i, j, k;$/;"	l
k	misc.c	/^    int levels, i,j,k;$/;"	l
k	misc.c	/^  int i, k, cnt, edge;$/;"	l
k	misc.c	/^  int i, k, edge;$/;"	l
k	moldyn.cu	/^    int i, j, k, l, m, ii, jj, n_blk;$/;"	l
k	moldyn.cu	/^    int i, j, k, n = 0; $/;"	l
k	moldyn.cu	/^  int      tmp,procs,i,j,k,ii, start_time;$/;"	l
k	moldyn.cu	/^ int n, k,  j, i, npoints;$/;"	l
k	regular/roc.cu	/^                    int k = omalloc(key_size);$/;"	l
k	regular/rog.cu	/^				int k  = omalloc(key_size);\/\/The first byte stores size of the key, and the second byte stores the size of the val$/;"	l
k	regular/ros.cu	/^					short k  = omalloc(2+key_size);\/\/The first byte stores size of the key$/;"	l
k	stencil.h	/^	int k = offset[0];	$/;"	l
key	metis.h	/^  idxtype key;$/;"	m	struct:KeyValueType
key	regular.h	/^        unsigned int key = 0;$/;"	l
key	regular/gpu_kernel.cu	/^			void *key = srcobject->get_key_address(index);	$/;"	l
key	regular/roc.cu	/^            void *key = object->get_key_address(i); $/;"	l
key	regular/rog.cu	/^            void *key = object->get_key_address(i); $/;"	l
key	regular/ros.cu	/^			void *key = object->get_key_address(i);$/;"	l
key1	regular/rog.cu	/^            int key1;$/;"	l
key_addr1	regular/rog.cu	/^		void *key_addr1 = get_key_address(bucket_index1);$/;"	l
key_addr1	regular/ros.cu	/^		void *key_addr1 = get_key_address(bucket_index1);$/;"	l
key_addr2	regular/rog.cu	/^		void *key_addr2 = get_key_address(bucket_index2);$/;"	l
key_addr2	regular/ros.cu	/^		void *key_addr2 = get_key_address(bucket_index2);$/;"	l
key_address	regular/roc.cu	/^                    void * key_address = get_address(k);$/;"	l
key_data	regular/roc.cu	/^                    void *key_data = get_key_address(index); $/;"	l
key_data	regular/rog.cu	/^				void *key_data = get_key_address(index);$/;"	l
key_data	regular/ros.cu	/^					void *key_data = get_key_address(index);$/;"	l
key_data_size	regular/roc.cu	/^                    unsigned key_data_size = get_key_size(index);$/;"	l
key_data_start	regular/rog.cu	/^				void *key_data_start = oget_address(k);$/;"	l
key_data_start	regular/ros.cu	/^					void *key_data_start = key_size_address + 2;$/;"	l
key_index	regular/data_type.h	/^    unsigned int *key_index;$/;"	m	struct:output
key_index	regular/roc.cu	/^    unsigned key_index = buckets[index].key_index;$/;"	l
key_index	regular/roc.h	/^    int key_index;$/;"	m	struct:intl
key_index	regular/rog.cu	/^	unsigned int key_index = ((unsigned int *)&buckets[bucket_index])[0]; $/;"	l
key_index	regular/ros.cu	/^	unsigned short key_index = ((unsigned short *)&buckets[bucket_index])[0]; $/;"	l
key_index	regular/ros.cu	/^	unsigned short key_index = ((unsigned short *)&buckets[bucket_index])[0];$/;"	l
key_index	regular/ros.cu	/^	unsigned short key_index = \/*get_key_index(bucket_index);*\/((unsigned short *)&buckets[bucket_index])[0]; $/;"	l
key_num	regular/data_type.h	/^    unsigned int key_num;$/;"	m	struct:output
key_size	regular/data_type.h	/^    unsigned int key_size;$/;"	m	struct:output
key_size	regular/gpu_kernel.cu	/^			int key_size = srcobject->get_key_size(index);  	$/;"	l
key_size	regular/roc.cu	/^            unsigned key_size = object->get_key_size(i);$/;"	l
key_size	regular/rog.cu	/^            unsigned key_size = object->get_key_size(i);$/;"	l
key_size	regular/ros.cu	/^			int key_size = object->get_key_size(i);$/;"	l
key_size1	regular/rog.cu	/^		unsigned short key_size1 = get_key_size(bucket_index1);	$/;"	l
key_size1	regular/ros.cu	/^		unsigned short key_size1 = get_key_size(bucket_index1);	$/;"	l
key_size2	regular/rog.cu	/^		unsigned short key_size2 = get_key_size(bucket_index2);	$/;"	l
key_size2	regular/ros.cu	/^		unsigned short key_size2 = get_key_size(bucket_index2);	$/;"	l
key_size_address	regular/rog.cu	/^	char *key_size_address = (char *)oget_address(key_index);$/;"	l
key_size_address	regular/ros.cu	/^					char *key_size_address = (char *)oget_address(k);$/;"	l
key_size_address	regular/ros.cu	/^	char *key_size_address = (char *)oget_address(key_index);$/;"	l
key_size_per_bucket	regular/roc.h	/^        unsigned int key_size_per_bucket[NUM_BUCKETS_G];$/;"	m	struct:roc
key_size_per_bucket	regular/rog.h	/^		unsigned int key_size_per_bucket[NUM_BUCKETS_G];$/;"	m	struct:Reduction_Object_GPU
keys	irregular/roc.h	/^	KEY keys[NUM_BUCKETS_G];$/;"	m	struct:Reduction_Object_C
keys	irregular/rog.h	/^	KEY keys[NUM_BUCKETS_G];$/;"	m	struct:Reduction_Object_G
keys	irregular/ros.h	/^		KEY keys[NUM_BUCKETS_S];$/;"	m	struct:Reduction_Object_S
keytmp	regular/hash.h	/^       	int keytmp;$/;"	l
keytmp	regular/rog.cu	/^				int keytmp ;$/;"	l
keytmp1	regular/hash.h	/^	int keytmp1;$/;"	l
kmeans_value	km.cu	/^struct kmeans_value$/;"	s	file:
kvn	regular/rog.cu	/^	unsigned long long int kvn = 0;$/;"	l
kvn	regular/ros.cu	/^	int kvn = 0;$/;"	l
l	input/gen.c	/^    int i, j, k, l, m, ii, jj, n_blk;$/;"	l
l	moldyn.cu	/^    int i, j, k, l, m, ii, jj, n_blk;$/;"	l
label	metis.h	/^  idxtype *label;$/;"	m	struct:graphdef
lap	misc.c	/^    int lap;$/;"	l
lap_time	misc.c	/^static double lap_time = 0.0;$/;"	v	file:
lap_time	timer.c	/^   double lap_time;$/;"	l
lap_timer	timer.c	/^double lap_timer()$/;"	f
lap_timer_	timer.c	/^double lap_timer_()$/;"	f
last	misc.c	/^    int i, j, k, degree, max, root=0, p, cur, last, reverse = 1;$/;"	l
last_app	misc.c	/^    int i, j, k, *last_app, n_reuse; $/;"	l
last_offset	regular/splitter.cpp	/^	int last_offset = my_offset_start_ + my_num_offsets_ - 1;$/;"	l
launch	irregular/irregular_runtime.cu	/^void *IrregularRuntime::launch(void *arg)$/;"	f	class:IrregularRuntime
launch	lib/stencil_runtime.cu	/^void *StencilRuntime::launch(void *arg)$/;"	f	class:StencilRuntime
lb	misc.c	/^    int i, lb, ub, ep0, ep1, localL, localR;$/;"	l
lb	misc.c	/^    int i, p, lb, ub, pt, bp, ip, jp, localI, localP;$/;"	l
level	misc.c	/^    int level, npart, psize, npass, nshift;$/;"	l
levels	misc.c	/^    int levels, i,j,k;$/;"	l
levels	misc.c	/^    j <<= levels;$/;"	l
line	misc.c	/^  char *line, *oldstr, *newstr;$/;"	l
line_size	lib/data_util.cpp	/^      			size_t line_size = ss[0] * elm_size;$/;"	l
line_size	lib/grid_util.cc	/^      size_t line_size = ss[0] * elm_size;$/;"	l
linear_offset	lib/data_util.cpp	/^  	intptr_t linear_offset = GridCalcOffset3D(subgrid_offset, grid_size) * elm_size;$/;"	l
linear_offset	lib/grid_util.cc	/^  intptr_t linear_offset =$/;"	l
linear_offset_dst	lib/buffer.cpp	/^				intptr_t linear_offset_dst = GridCalcOffset3D(dst_start, size_)* elm_size_;$/;"	l
linear_offset_dst	lib/buffer.cpp	/^			intptr_t linear_offset_dst = GridCalcOffset3D(dst_start, size_) * elm_size_;$/;"	l
linear_offset_dst	lib/buffer_cuda.cu	/^				intptr_t linear_offset_dst = GridCalcOffset3D(dst_start, size_)* elm_size_;$/;"	l
linear_offset_dst	lib/buffer_cuda.cu	/^			intptr_t linear_offset_dst = GridCalcOffset3D(dst_start, size_) * elm_size_;$/;"	l
linear_offset_src	lib/buffer.cpp	/^				intptr_t linear_offset_src = GridCalcOffset3D(src_start, src->size()) * elm_size_;$/;"	l
linear_offset_src	lib/buffer.cpp	/^			intptr_t linear_offset_src = GridCalcOffset3D(src_start, src->size()) * elm_size_;$/;"	l
linear_offset_src	lib/buffer_cuda.cu	/^				intptr_t linear_offset_src = GridCalcOffset3D(src_start, src.size()) * elm_size_;$/;"	l
linear_offset_src	lib/buffer_cuda.cu	/^			intptr_t linear_offset_src = GridCalcOffset3D(src_start, src.size()) * elm_size_;$/;"	l
linear_size	lib/compute_cuda.cu	/^	__shared__ int linear_size;$/;"	l
linear_size	lib/grid_cpu.cpp	/^	size_t linear_size = size.accumulate(num_dims_);$/;"	l
linear_size	lib/grid_cuda.cu	/^		size_t linear_size = size.accumulate(num_dims_);$/;"	l
linear_size	lib/grid_cuda.cu	/^	size_t linear_size = copy_size.accumulate(num_dims_);$/;"	l
linear_size	lib/grid_cuda.cu	/^	size_t linear_size = size.accumulate(num_dims_);$/;"	l
linear_tile	lib/CU_DS.h	/^struct linear_tile$/;"	s
localI	misc.c	/^    int i, p, lb, ub, pt, bp, ip, jp, localI, localP;$/;"	l
localL	misc.c	/^    int i, lb, ub, ep0, ep1, localL, localR;$/;"	l
localP	misc.c	/^    int i, p, lb, ub, pt, bp, ip, jp, localI, localP;$/;"	l
localR	misc.c	/^    int i, lb, ub, ep0, ep1, localL, localR;$/;"	l
local_group_id	regular/rog.cu	/^		int local_group_id = tid\/WARP_SIZE;$/;"	l
local_halo_buf	lib/grid_cuda.cu	/^	char *local_halo_buf = (char *)(fw? halo_self_fw()[dim]->Get() : halo_self_bw()[dim]->Get());$/;"	l
local_halo_size	lib/grid_cuda.cu	/^	IndexArray local_halo_size = my_real_size_;$/;"	l
local_linear_offset	lib/grid_cuda.cu	/^	size_t local_linear_offset = GridCalcOffset3D(local_offset, local_halo_size);$/;"	l
locator	metis.h	/^  idxtype *locator;$/;"	m	struct:PQueueType
locks	irregular/roc.h	/^	int locks[NUM_BUCKETS_G];$/;"	m	struct:Reduction_Object_C
locks	irregular/rog.h	/^	int locks[NUM_BUCKETS_G];$/;"	m	struct:Reduction_Object_G
locks	irregular/ros.h	/^		int locks[NUM_BUCKETS_S]; $/;"	m	struct:Reduction_Object_S
locks	regular/roc.h	/^        int locks[NUM_BUCKETS_G];$/;"	m	struct:roc
locks	regular/rog.h	/^		int locks[NUM_BUCKETS_G];$/;"	m	struct:Reduction_Object_GPU
locks	regular/ros.h	/^		int locks[NUM_BUCKETS_S]; \/\/every bucket has a lock$/;"	m	struct:Reduction_Object
lsize	lib/test/test_util.h	/^  IndexArray lsize = g->my_size();$/;"	l
lt	timer.c	/^struct timeval lt;	\/* save previous time when lap_timer() called *\/$/;"	v	typeref:struct:timeval
m	input/gen.c	/^    int i, j, k, l, m, ii, jj, n_blk;$/;"	l
m	misc.c	/^    int  max_degree, init_max_part, cur_max_part, m, max;$/;"	l
m	moldyn.cu	/^    int i, j, k, l, m, ii, jj, n_blk;$/;"	l
m	regular/hash.h	/^    unsigned int m;$/;"	l
m	stencil.h	/^	int m;$/;"	l
ma_cur_ptr	misc.c	/^byte *ma_cur_ptr = malloc_buf;$/;"	v
ma_end_ptr	misc.c	/^byte *ma_end_ptr = malloc_buf + sizeof(malloc_buf);$/;"	v
ma_postponed	misc.c	/^byte *ma_postponed = NULL;$/;"	v
main	input/gen.c	/^main(int argc, char **argv)$/;"	f
main	km.cu	/^int main(int argc, char *argv[])$/;"	f
main	main.cpp	/^int main(int argc, char *argv[])$/;"	f
main	main1.cpp	/^int main()$/;"	f
main	main2.cpp	/^int main(int argc, char *argv[])$/;"	f
main	moldyn.cu	/^main(int argc, char **argv)$/;"	f
malloc_buf	misc.c	/^byte malloc_buf[MAXBUF];$/;"	v
map	irregular.h	/^	DEVICE bool map(T *object, void *point_data, int *part_index, void *edge_data, void *parameter, unsigned int task_id, unsigned int part_id)$/;"	f	namespace:FGPU
map	regular.h	/^DEVICE bool map(T *object, void *global_data, int index, void *parameter, int device_type)$/;"	f	namespace:FFGPU
max	input/misc.h	16;"	d
max	metis.h	/^  float max[2][MAXNCON];$/;"	m	struct:vpwgtdef
max	misc.c	/^    int  max_degree, init_max_part, cur_max_part, m, max;$/;"	l
max	misc.c	/^    int i, j, k, degree, max, root=0, p, cur, last, reverse = 1;$/;"	l
max	misc.h	16;"	d
max3	input/misc.h	17;"	d
max3	misc.h	17;"	d
max_degree	misc.c	/^    int  i, max_degree, *hcnt;$/;"	l
max_degree	misc.c	/^    int  max_degree, init_max_part, cur_max_part, m, max;$/;"	l
max_xyz	misc.c	/^    double max_xyz[3], min_xyz[3];$/;"	l
maxcore	metis.h	/^  int maxcore, ccore;$/;"	m	struct:workspacedef
maxgain	metis.h	/^  int maxgain;$/;"	m	struct:PQueueType
maxnodes	metis.h	/^  int maxnodes;$/;"	m	struct:PQueueType
maxvwgt	metis.h	/^  int maxvwgt;			\/* The maximum allowed weight for a vertex *\/$/;"	m	struct:controldef
memory_offset	regular/roc.h	/^        unsigned memory_offset;$/;"	m	struct:roc
memory_offset	regular/rog.h	/^		unsigned int memory_offset;$/;"	m	struct:Reduction_Object_GPU
memory_offset	regular/ros.h	/^		unsigned int memory_offset;$/;"	m	struct:Reduction_Object
memory_pool	regular/roc.h	/^        int memory_pool[GLOBAL_POOL_SIZE];$/;"	m	struct:roc
memory_pool	regular/rog.h	/^		unsigned int memory_pool[GLOBAL_POOL_SIZE];$/;"	m	struct:Reduction_Object_GPU
memory_pool	regular/ros.h	/^		unsigned int memory_pool[SHARED_POOL_SIZE]; \/\/the memory pool in each object$/;"	m	struct:Reduction_Object
merge	regular/gpu_kernel.cu	/^__device__ void merge(T1 *dstobject, T2 *srcobject)$/;"	f
merge	regular/roc.cu	/^void roc::merge(struct roc *object)$/;"	f	class:roc
merge	regular/rog.cu	/^__device__ void Reduction_Object_GPU::merge(SO *object)$/;"	f	class:Reduction_Object_GPU
merge	regular/ros.cu	/^__device__ inline void Reduction_Object::merge(Reduction_Object* object, unsigned int k, unsigned int value_size)$/;"	f	class:Reduction_Object
merge_args	irregular/cpu_args.h	/^struct merge_args$/;"	s
merge_args	irregular/irregular_runtime.cu	/^	struct merge_args merge_args[CPU_THREADS]; $/;"	l
merge_cobjects	irregular/irregular_runtime.cu	/^void IrregularRuntime::merge_cobjects()$/;"	f	class:IrregularRuntime
mergec	irregular/roc.cu	/^void Reduction_Object_C::mergec(Reduction_Object_C *object, int tid)$/;"	f	class:Reduction_Object_C
mergecgd	irregular/gpu_kernel.cu	/^__global__ void mergecgd(Gobject *object1, Gobject *object2)$/;"	f
mergeg	irregular/rog.cu	/^__device__ void Reduction_Object_G::mergeg(Reduction_Object_G *object)$/;"	f	class:Reduction_Object_G
mergeg	regular/rog.cu	/^__device__ void Reduction_Object_GPU::mergeg(GO *object)$/;"	f	class:Reduction_Object_GPU
merges	irregular/rog.cu	/^__device__ void Reduction_Object_G::merges(Sobject* object)$/;"	f	class:Reduction_Object_G
mergetc	irregular/cpu_kernel.cu	/^void *mergetc(void *arg)$/;"	f
metisprocess	misc.c	/^metisprocess(int n_nodes, int n_edges, int (*el)[2], int n, long (*repos)[2])$/;"	f
metisprocess2	misc.c	/^metisprocess2(int n_nodes, int n_edges, int *partners, int *from, int n, long (*repos)[2])$/;"	f
min	input/misc.h	15;"	d
min	misc.h	15;"	d
min_dist	regular.h	/^        float min_dist = 65536*65;$/;"	l
min_partition	lib/grid_view.h	/^	IndexArray min_partition;$/;"	m	class:Grid_view
min_xyz	misc.c	/^    double max_xyz[3], min_xyz[3];$/;"	l
mincut	metis.h	/^  int mincut, minvol;$/;"	m	struct:graphdef
minvol	metis.h	/^  int mincut, minvol;$/;"	m	struct:graphdef
mustfree	metis.h	/^  int mustfree;$/;"	m	struct:PQueueType
mutex	irregular/cpu_args.h	/^    pthread_mutex_t *mutex;$/;"	m	struct:cpu_args
mutex	irregular/cpu_kernel.cu	/^    pthread_mutex_t *mutex = args->mutex;$/;"	l
mutex	irregular/irregular_runtime.cu	/^        pthread_mutex_t mutex;$/;"	l
mutex	regular/cpu_kernel.cu	/^    pthread_mutex_t *mutex = runtime->mutex;$/;"	l
mutex	regular/regular_runtime.h	/^	pthread_mutex_t *mutex;$/;"	m	class:RegularRuntime
my_edge_data	irregular/partition.h	/^	void *my_edge_data(){return my_edge_data_;}$/;"	f	class:partition
my_edge_data_	irregular/partition.h	/^	void *my_edge_data_;$/;"	m	class:partition
my_edge_data_d	irregular/partition_cuda.h	/^		void *my_edge_data_d(){return my_edge_data_d_;}$/;"	f	class:partition_cuda
my_edge_data_d_	irregular/partition_cuda.h	/^		void *my_edge_data_d_;$/;"	m	class:partition_cuda
my_edges	irregular/partition.h	/^	EDGE *my_edges(){return my_edges_;}$/;"	f	class:partition
my_edges	irregular/partition_view.cpp	/^	vector<EDGE> *my_edges = new vector<EDGE>;$/;"	l
my_edges	irregular/partitioner.cpp	/^		EDGE *my_edges = gpu_edges[j];$/;"	l
my_edges_	irregular/partition.h	/^	EDGE *my_edges_;$/;"	m	class:partition
my_edges_d	irregular/partition_cuda.h	/^		void *my_edges_d(){return my_edges_d_;}$/;"	f	class:partition_cuda
my_edges_d_	irregular/partition_cuda.h	/^		void *my_edges_d_;$/;"	m	class:partition_cuda
my_idx	lib/grid_view.h	/^	IndexArray my_idx;	\/\/my process index in multi-dimension$/;"	m	class:Grid_view
my_input	regular/splitter.cpp	/^	void *my_input = (char *)input_ + my_input_start;$/;"	l
my_input_end	regular/splitter.cpp	/^	int my_input_end = offsets_[last_offset].offset + offsets_[last_offset].size - 1;$/;"	l
my_input_size	regular/splitter.cpp	/^	int my_input_size = my_input_end - my_input_start + 1;$/;"	l
my_input_start	regular/splitter.cpp	/^	int my_input_start = offsets_[my_offset_start_].offset; $/;"	l
my_node_data	irregular/partition.h	/^	void *my_node_data(){return my_node_data_;}$/;"	f	class:partition
my_node_data_	irregular/partition.h	/^	void *my_node_data_;$/;"	m	class:partition
my_node_data_d	irregular/partition_cuda.h	/^		void *my_node_data_d(){return my_node_data_d_;}$/;"	f	class:partition_cuda
my_node_data_d	irregular/partition_mpi.h	/^	void *my_node_data_d(){return my_node_data_d_;}$/;"	f	class:partition_mpi
my_node_data_d_	irregular/partition_cuda.h	/^		void *my_node_data_d_;$/;"	m	class:partition_cuda
my_node_data_d_	irregular/partition_mpi.h	/^	void *my_node_data_d_;$/;"	m	class:partition_mpi
my_node_data_device	irregular/partition_cuda.h	/^		void *my_node_data_device(){return my_node_data_device_;}$/;"	f	class:partition_cuda
my_node_data_device_	irregular/partition_cuda.h	/^		void *my_node_data_device_;$/;"	m	class:partition_cuda
my_node_start	irregular/partition.h	/^	IRIndex my_node_start(){return my_node_start_;}$/;"	f	class:partition
my_node_start	irregular/partition_view.h	/^	int my_node_start(){return my_node_start_;}	$/;"	f	class:partition_view
my_node_start_	irregular/partition.h	/^	IRIndex  my_node_start_;$/;"	m	class:partition
my_node_start_	irregular/partition_view.h	/^	int my_node_start_;$/;"	m	class:partition_view
my_nodes	irregular/partition_view.h	/^	vector<int> *my_nodes;$/;"	m	class:partition_view
my_num_edges	irregular/partition.h	/^	IRIndex my_num_edges(){return my_num_edges_;}$/;"	f	class:partition
my_num_edges_	irregular/partition.h	/^	IRIndex  my_num_edges_;$/;"	m	class:partition
my_num_nodes	irregular/partition.h	/^	IRIndex my_num_nodes(){return my_num_nodes_;}$/;"	f	class:partition
my_num_nodes	irregular/partition_view.h	/^	int my_num_nodes(){return my_num_nodes_;}$/;"	f	class:partition_view
my_num_nodes_	irregular/partition.h	/^	IRIndex  my_num_nodes_;$/;"	m	class:partition
my_num_nodes_	irregular/partition_view.h	/^	IRIndex my_num_nodes_; $/;"	m	class:partition_view
my_num_offsets_	regular/splitter.h	/^		int my_num_offsets_;$/;"	m	class:splitter
my_num_parts	irregular/partition_cpu.h	/^		int my_num_parts(){return my_num_parts_;}$/;"	f	class:partition_cpu
my_num_parts	irregular/partition_cuda.h	/^		int my_num_parts(){return my_num_parts_;}$/;"	f	class:partition_cuda
my_num_parts_	irregular/partition_cpu.h	/^		int my_num_parts_;$/;"	m	class:partition_cpu
my_num_parts_	irregular/partition_cuda.h	/^		int my_num_parts_;$/;"	m	class:partition_cuda
my_offset	lib/grid_mpi.h	/^  	const IndexArray& my_offset() const { return my_offset_; }$/;"	f	class:GridMPI
my_offset	lib/grid_view.h	/^	IndexArray my_offset;	\/\/my offset within the global grid$/;"	m	class:Grid_view
my_offset	regular/splitter.cpp	/^	Offset *my_offset = offsets_ + my_offset_start_; $/;"	l
my_offset_	lib/grid_mpi.h	/^	IndexArray my_offset_;	$/;"	m	class:GridMPI
my_offset_start_	regular/splitter.h	/^		int my_offset_start_;$/;"	m	class:splitter
my_own_node_number_	irregular/partition_mpi.h	/^	int my_own_node_number_;$/;"	m	class:partition_mpi
my_parts	irregular/partition_cpu.h	/^		Part *my_parts(){return my_parts_;}$/;"	f	class:partition_cpu
my_parts_	irregular/partition_cpu.h	/^		Part *my_parts_;$/;"	m	class:partition_cpu
my_parts_	irregular/partition_cuda.h	/^		void *my_parts_;$/;"	m	class:partition_cuda
my_parts_d	irregular/partition_cuda.h	/^		Part *my_parts_d(){return my_parts_d_;}$/;"	f	class:partition_cuda
my_parts_d_	irregular/partition_cuda.h	/^		Part *my_parts_d_;$/;"	m	class:partition_cuda
my_rank	lib/grid_view.h	/^	int my_rank;		\/\/my rank in linear ranking$/;"	m	class:Grid_view
my_rank	lib/stencil_runtime.h	/^	int my_rank(){return my_rank_;}$/;"	f	class:StencilRuntime
my_rank	lib/test/test_util.h	/^  ss << "[rank:" << my_rank << "] ";$/;"	l
my_rank	main.cpp	/^	int my_rank = sr->my_rank(); $/;"	l
my_rank	main2.cpp	/^	int my_rank;$/;"	l
my_rank_	irregular/irregular_runtime.h	/^	int my_rank_;$/;"	m	class:IrregularRuntime
my_rank_	irregular/partition_view.h	/^	int my_rank_;	$/;"	m	class:partition_view
my_rank_	lib/stencil_runtime.h	/^	int my_rank_;$/;"	m	class:StencilRuntime
my_rank_	regular/regular_runtime.h	/^	int my_rank_;$/;"	m	class:RegularRuntime
my_rank_	regular/splitter.h	/^		int my_rank_;$/;"	m	class:splitter
my_real_offset_	lib/grid_mpi.h	/^	IndexArray my_real_offset_; $/;"	m	class:GridMPI
my_real_size	lib/grid_mpi.h	/^  	const IndexArray& my_real_size() const { return my_real_size_; }$/;"	f	class:GridMPI
my_real_size	lib/stencil_runtime.cu	/^	IndexArray my_real_size;$/;"	l
my_real_size_	lib/grid_mpi.h	/^	IndexArray my_real_size_;$/;"	m	class:GridMPI
my_reduction_elm_num	irregular/partition_mpi.h	/^	int my_reduction_elm_num(){return  my_reduction_elm_num_;}$/;"	f	class:partition_mpi
my_reduction_elm_num_	irregular/partition_mpi.h	/^	int my_reduction_elm_num_;$/;"	m	class:partition_mpi
my_size	lib/grid_mpi.h	/^  	const IndexArray& my_size() const { return my_size_; }  $/;"	f	class:GridMPI
my_size	lib/grid_view.h	/^	IndexArray my_size;$/;"	m	class:Grid_view
my_size	lib/stencil_runtime.cu	/^	IndexArray my_size;$/;"	l
my_size_	lib/grid_mpi.h	/^	IndexArray my_size_;$/;"	m	class:GridMPI
mycomp	misc.c	/^static int mycomp (const void *i, const void *j)$/;"	f	file:
n	input/gen.c	/^    int i, j, k, n = 0; $/;"	l
n	input/gen.c	/^   int i, a, b, n= numMoles; $/;"	l
n	input/gen.c	/^ int n, k,  j, i, npoints;$/;"	l
n	misc.c	/^     int n_nodes, n_edges, (*el)[2], n;$/;"	l
n	misc.c	/^     int n_nodes, n_edges, *partners, *from, n;$/;"	l
n	misc.c	/^    double n;$/;"	l
n	misc.c	/^    int  i, j, k, p, n = 0;$/;"	l
n	misc.c	/^    int  i, j, k, p, q, n = 0;$/;"	l
n	misc.c	/^    int i, j, *n;                            	$/;"	l
n	misc.c	/^   int n_nodes, n_edges, (*el)[2], n, unit_sz, i, apply;$/;"	l
n	misc.c	/^   int n_nodes, n_edges, *partners, *from, n, unit_sz, i, apply;$/;"	l
n	moldyn.cu	/^    int i, j, k, n = 0; $/;"	l
n	moldyn.cu	/^ int n, k,  j, i, npoints;$/;"	l
n0	misc.c	/^    double n0;$/;"	l
nB	moldyn.cu	/^	int     nB;	\/* boxSize *\/$/;"	m	struct:_dsize_	file:
nPass	misc.c	/^int nPass = 4;$/;"	v
nShift	misc.c	/^	psize <<=nShift; $/;"	l
nShift	misc.c	/^int nShift = 3;$/;"	v
nTS	moldyn.cu	/^	int	nTS;	\/* num TimeSteps *\/$/;"	m	struct:_dsize_	file:
nU	moldyn.cu	/^	int	nU;	\/* neighbor Update rate *\/$/;"	m	struct:_dsize_	file:
n_blk	input/gen.c	/^    int i, j, k, l, m, ii, jj, n_blk;$/;"	l
n_blk	misc.c	/^    int i, j, k, n_blk, n_x, n_y, n_z, n_th;$/;"	l
n_blk	moldyn.cu	/^    int i, j, k, l, m, ii, jj, n_blk;$/;"	l
n_edges	misc.c	/^     int n_nodes, n_edges, (*el)[2], n;$/;"	l
n_edges	misc.c	/^     int n_nodes, n_edges, *partners, *from, n;$/;"	l
n_edges	misc.c	/^   int n_nodes, n_edges, (*el)[2], n, unit_sz, i, apply;$/;"	l
n_edges	misc.c	/^   int n_nodes, n_edges, *partners, *from, n, unit_sz, i, apply;$/;"	l
n_expanded	misc.c	/^    int *ind2, *taken, n_taken, *expanded, n_expanded, *from;$/;"	l
n_expanded	misc.c	/^    int *ind2, *taken, n_taken, *expanded, n_expanded;$/;"	l
n_inter	moldyn.cu	/^  int      tstep, n_tstep, n_moles, n_inter;$/;"	l
n_moles	moldyn.cu	/^   int i, j, iseed, n_moles;$/;"	l
n_moles	moldyn.cu	/^  int      tstep, n_tstep, n_moles, n_inter;$/;"	l
n_moles	moldyn.cu	/^int i, n_moles;$/;"	l
n_nodes	misc.c	/^     int n_nodes, n_edges, (*el)[2], n;$/;"	l
n_nodes	misc.c	/^     int n_nodes, n_edges, *partners, *from, n;$/;"	l
n_nodes	misc.c	/^   int n_nodes, n_edges, (*el)[2], n, unit_sz, i, apply;$/;"	l
n_nodes	misc.c	/^   int n_nodes, n_edges, *partners, *from, n, unit_sz, i, apply;$/;"	l
n_pieces	misc.c	/^    int  i, j, k, t, n_pieces, root, root2, p, done, iter, real_i;$/;"	l
n_reuse	misc.c	/^    int i, j, k, *last_app, n_reuse; $/;"	l
n_reuse2	misc.c	/^    int n_reuse2;$/;"	l
n_taken	misc.c	/^    int *ind2, *taken, n_taken, *expanded, n_expanded, *from;$/;"	l
n_taken	misc.c	/^    int *ind2, *taken, n_taken, *expanded, n_expanded;$/;"	l
n_th	misc.c	/^    int i, j, k, n_blk, n_x, n_y, n_z, n_th;$/;"	l
n_tstep	moldyn.cu	/^  int      tstep, n_tstep, n_moles, n_inter;$/;"	l
n_x	misc.c	/^    int i, j, k, n_blk, n_x, n_y, n_z, n_th;$/;"	l
n_xyz	input/gen.c	/^    int *nodes, *start, n_xyz[3], neiblk[27], xd,yd,zd, x,y,z;$/;"	l
n_xyz	moldyn.cu	/^    int *nodes, *start, n_xyz[3], neiblk[27], xd,yd,zd, x,y,z;$/;"	l
n_y	misc.c	/^    int i, j, k, n_blk, n_x, n_y, n_z, n_th;$/;"	l
n_z	misc.c	/^    int i, j, k, n_blk, n_x, n_y, n_z, n_th;$/;"	l
naive	moldyn.cu	/^  int      update_freq = 1, naive = 0;$/;"	l
nbnd	metis.h	/^  int nbnd;$/;"	m	struct:graphdef
ncon	metis.h	/^  int ncon;			\/* The # of constrains *\/ $/;"	m	struct:graphdef
ndegrees	metis.h	/^ int ndegrees;          	\/* The number of different ext-degrees *\/$/;"	m	struct:rinfodef
ndegrees	metis.h	/^ int ndegrees;          	\/* The number of different ext-degrees *\/$/;"	m	struct:vrinfodef
ned	metis.h	/^  idxtype ed, ned;$/;"	m	struct:vedegreedef
nedges	metis.h	/^  int nvtxs, nedges;		\/* The # of vertices and edges in the graph *\/$/;"	m	struct:graphdef
neiblk	input/gen.c	/^    int *nodes, *start, n_xyz[3], neiblk[27], xd,yd,zd, x,y,z;$/;"	l
neiblk	moldyn.cu	/^    int *nodes, *start, n_xyz[3], neiblk[27], xd,yd,zd, x,y,z;$/;"	l
neighUpdate	moldyn.cu	/^int	  neighUpdate;$/;"	v
neighUpdate	moldyn.h	/^         neighUpdate,           \/*  timesteps between interaction updates *\/$/;"	v
neighbor	lib/grid_view.cpp	/^    		IndexArray neighbor = my_idx; \/\/ Usually {0, 0, my_rank_}$/;"	l
new_edges	irregular/reorder.h	/^	int new_edges;$/;"	m	class:Reorder
new_node_data	irregular/partition_view.cpp	/^	void *new_node_data = malloc(total_nodes * node_data_elm_size_);$/;"	l
new_offset	lib/data_util.cpp	/^        			IndexArray new_offset = cur_offset;$/;"	l
new_offset	lib/grid_util.cc	/^        IndexArray new_offset = cur_offset;$/;"	l
new_part	irregular/cpu_kernel.cu	/^    struct part new_part;$/;"	l
newstr	misc.c	/^  char *line, *oldstr, *newstr;$/;"	l
next	metis.h	/^  struct ListNodeType *prev, *next;     \/* It's a doubly-linked list *\/$/;"	m	struct:ListNodeType	typeref:struct:ListNodeType::
next_offset	lib/data_util.cpp	/^    		PSIndex next_offset;$/;"	l
next_offset	lib/grid_util.cc	/^    PSIndex next_offset;$/;"	l
ngainspan	metis.h	/^  int pgainspan, ngainspan;     \/* plus and negative gain span *\/$/;"	m	struct:PQueueType
nid	metis.h	/^ int id, ed, nid;            	\/* ID\/ED of nodes *\/$/;"	m	struct:vrinfodef
ninter	input/gen.c	/^int      ninter;                \/*  number of interacting molecules pairs *\/$/;"	v
ninter	moldyn.cu	/^int      ninter;                \/*  number of interacting molecules pairs *\/$/;"	v
ninter	moldyn.h	/^         ninter,                \/*  number of interacting molecules pairs *\/$/;"	v
nmaxvwgt	metis.h	/^  float nmaxvwgt;		\/* The maximum allowed weight for a vertex for each constrain *\/$/;"	m	struct:controldef
nnodes	metis.h	/^  int nnodes;$/;"	m	struct:PQueueType
node_coordinates_	irregular/irregular_runtime.h	/^	void *node_coordinates_;$/;"	m	class:IrregularRuntime
node_data	irregular/partition_view.cpp	/^			char *node_data = (char *)peer_request_node_data_[i];$/;"	l
node_data_elm_size	irregular/partition.h	/^	int node_data_elm_size(){return node_data_elm_size_;}$/;"	f	class:partition
node_data_elm_size_	irregular/irregular_runtime.h	/^	int node_data_elm_size_;$/;"	m	class:IrregularRuntime
node_data_elm_size_	irregular/partition.h	/^	int node_data_elm_size_;$/;"	m	class:partition
node_data_elm_size_	irregular/partition_view.h	/^	int node_data_elm_size_;$/;"	m	class:partition_view
node_id	irregular/partition_view.cpp	/^				int node_id = node_ids[j] - my_node_start_;		$/;"	l
node_ids	irregular/partition_view.cpp	/^			int *node_ids = peer_request_nodes_[i];$/;"	l
node_num	irregular/partition_view.cpp	/^			int node_num = peer_request_num_nodes_[i];$/;"	l
node_num_dims_	irregular/irregular_runtime.h	/^	int node_num_dims_;$/;"	m	class:IrregularRuntime
node_offsets	regular/regular_runtime.cu	/^	Offset *node_offsets = offsets_pin_;$/;"	l
node_start	irregular/partition_view.cpp	/^			int node_start = peer_request_num_nodes_sum_[i];	$/;"	l
nodes	input/gen.c	/^    int *nodes, *start, n_xyz[3], neiblk[27], xd,yd,zd, x,y,z;$/;"	l
nodes	irregular/partition_view.cpp	/^			int * nodes = remote_nodes_array_[i];$/;"	l
nodes	metis.h	/^  ListNodeType *nodes;$/;"	m	struct:PQueueType
nodes	misc.c	/^    int  *nodes, *degree, *cnt, *ind2, *nodes2, *tp;$/;"	l
nodes	misc.c	/^    int *nodes, *start, *nodes2, *start2;$/;"	l
nodes	moldyn.cu	/^    int *nodes, *start, n_xyz[3], neiblk[27], xd,yd,zd, x,y,z;$/;"	l
nodes2	misc.c	/^    int  *nodes, *degree, *cnt, *ind2, *nodes2, *tp;$/;"	l
nodes2	misc.c	/^    int *nodes, *start, *nodes2, *start2;$/;"	l
npart	misc.c	/^    int i, j, k, a, npart;$/;"	l
npart	misc.c	/^    int level, npart, psize, npass, nshift;$/;"	l
npart	misc.c	/^    int npart, *part, *ind2;		\/* beginning of a part *\/$/;"	l
npart_arg	misc.c	/^int npart_arg = 4096;	$/;"	v
nparts	misc.c	/^    int nparts, options[10];$/;"	l
npass	misc.c	/^    int  pass, npass, nshift;$/;"	l
npass	misc.c	/^    int level, npart, psize, npass, nshift;$/;"	l
npoints	input/gen.c	/^ int n, k,  j, i, npoints;$/;"	l
npoints	moldyn.cu	/^ int n, k,  j, i, npoints;$/;"	l
nproc	input/gen.c	/^    int nproc = 8;$/;"	l
npwgts	metis.h	/^  float *npwgts;		\/* The normalized partition weights *\/$/;"	m	struct:graphdef
nrinfo	metis.h	/^  NRInfoType *nrinfo;$/;"	m	struct:graphdef
nrinfodef	metis.h	/^struct nrinfodef {$/;"	s
nsd	moldyn.cu	/^      static int nsd =1073741823;$/;"	l	file:
nseps	metis.h	/^  int nseps;			\/* The number of separators to be found during multiple bisections *\/$/;"	m	struct:controldef
nshift	misc.c	/^    int  pass, npass, nshift;$/;"	l
nshift	misc.c	/^    int level, npart, psize, npass, nshift;$/;"	l
ntimes	misc.c	/^     int i, j, k, ntimes, r1, r2, *ind2, *p;$/;"	l
ntimes	misc.c	/^     int i, ntimes, r1, r2, *ind=NULL, *ind2=NULL, *p;$/;"	l
num	km.cu	/^    float num;$/;"	m	struct:kmeans_value	file:
numMoles	input/gen.c	/^int	 numMoles;$/;"	v
numMoles	moldyn.cu	/^int	  numMoles;$/;"	v
numMoles	moldyn.h	/^int      numMoles,              \/*  number of molecules                   *\/$/;"	v
numProcs	moldyn.h	/^         numProcs,              \/*  number of processors to use           *\/$/;"	v
numTimeSteps	moldyn.cu	/^int	  numTimeSteps;$/;"	v
numTimeSteps	moldyn.h	/^         numTimeSteps;          \/*  number of time-steps to simulate for  *\/$/;"	v
num_blocks	irregular/gpu_kernel.cu	/^    const unsigned int num_blocks = gridDim.x;$/;"	l
num_blocks	lib/compute_cuda.cu	/^	const unsigned int num_blocks = gridDim.x;$/;"	l
num_buckets	regular/roc.h	/^        unsigned num_buckets;$/;"	m	struct:roc
num_buckets	regular/rog.h	/^		unsigned int num_buckets;$/;"	m	struct:Reduction_Object_GPU
num_buckets	regular/ros.h	/^		unsigned int num_buckets;$/;"	m	struct:Reduction_Object
num_devices	lib/grid_cpu.h	/^	int num_devices(){return num_devices_;}$/;"	f	class:GridCPU
num_devices	lib/grid_cuda.h	/^	int num_devices(){return num_devices_;}$/;"	f	class:GridCuda
num_devices_	irregular/irregular_runtime.h	/^	int num_devices_;$/;"	m	class:IrregularRuntime
num_devices_	irregular/partitioner.h	/^	int num_devices_;$/;"	m	class:Partitioner
num_devices_	lib/grid_cpu.h	/^	int num_devices_;$/;"	m	class:GridCPU
num_devices_	lib/grid_cuda.h	/^	int num_devices_;$/;"	m	class:GridCuda
num_devices_	lib/grid_mpi.h	/^	int num_devices_;$/;"	m	class:GridMPI
num_devices_	lib/stencil_runtime.h	/^	int num_devices_;$/;"	m	class:StencilRuntime
num_devices_	regular/regular_runtime.h	/^	int num_devices_;$/;"	m	class:RegularRuntime
num_dims	irregular/partitioner.h	/^	int num_dims;$/;"	m	class:Partitioner
num_dims	irregular/reorder.h	/^	int num_dims;$/;"	m	class:Reorder
num_dims	lib/buffer.cpp	/^	int num_dims = num_dims_;$/;"	l
num_dims	lib/buffer.h	/^	int num_dims() const{return num_dims_;}$/;"	f	class:Buffer
num_dims	lib/buffer_cuda.cu	/^	int num_dims = num_dims_;$/;"	l
num_dims	lib/compute_cpu.cpp	/^	int num_dims = runtime->num_dims();$/;"	l
num_dims	lib/grid.h	/^	int num_dims() const$/;"	f	class:Grid
num_dims	lib/grid_view.h	/^	int num_dims;        	\/\/for global data$/;"	m	class:Grid_view
num_dims	lib/stencil_runtime.h	/^	int num_dims(){return num_dims_;}$/;"	f	class:StencilRuntime
num_dims_	lib/buffer.h	/^	int num_dims_;$/;"	m	class:Buffer
num_dims_	lib/grid.h	/^	int num_dims_;$/;"	m	class:Grid
num_dims_	lib/grid_mpi.cu	/^    		CopyinSubgrid(unit_size(), num_dims_,$/;"	l
num_dims_	lib/grid_mpi.cu	/^    		CopyoutSubgrid(unit_size(), num_dims_,$/;"	l
num_dims_	lib/stencil_creator.h	/^	int num_dims_;$/;"	m	class:StencilCreator
num_dims_	lib/stencil_runtime.h	/^	int num_dims_;$/;"	m	class:StencilRuntime
num_edges	irregular/partitioner.h	/^	IRIndex num_edges;$/;"	m	class:Partitioner
num_edges	irregular/reorder.h	/^	int num_edges;$/;"	m	class:Reorder
num_eles_	lib/grid.h	/^	size_t num_eles_;$/;"	m	class:Grid
num_elms	irregular/reduction_array.h	/^	IRIndex num_elms(){return num_elms_;}$/;"	f	class:reduction_array
num_elms_	irregular/reduction_array.h	/^	IRIndex num_elms_;$/;"	m	class:reduction_array
num_gpus_	irregular/irregular_runtime.h	/^	int num_gpus_;$/;"	m	class:IrregularRuntime
num_gpus_	irregular/partitioner.h	/^	int num_gpus_;$/;"	m	class:Partitioner
num_gpus_	lib/stencil_runtime.h	/^	int num_gpus_;$/;"	m	class:StencilRuntime
num_gpus_	regular/regular_runtime.h	/^	int num_gpus_;$/;"	m	class:RegularRuntime
num_groups	regular/gpu_kernel.cu	/^    const int num_groups = num_groupss;\/\/get_num_groups();\/\/floor((double)SHARED_SIZE\/sizeof(SO));$/;"	l
num_groupss	regular/gpu_kernel.cu	/^    __shared__ unsigned int num_groupss;$/;"	l
num_iters_	irregular/irregular_runtime.h	/^	int num_iters_;$/;"	m	class:IrregularRuntime
num_iters_	lib/stencil_creator.h	/^	int num_iters_;$/;"	m	class:StencilCreator
num_iters_	lib/stencil_runtime.h	/^	int num_iters_;$/;"	m	class:StencilRuntime
num_nodes	irregular/partition_view.cpp	/^			int num_nodes = remote_num_nodes_[i];$/;"	l
num_offsets	regular/data_partition_mpi.h	/^	int num_offsets(){return offset_number_;}$/;"	f	class:data_partition_mpi
num_offsets_	regular/regular_runtime.h	/^	int num_offsets_;$/;"	m	class:RegularRuntime
num_offsets_	regular/splitter.h	/^		int num_offsets_;$/;"	m	class:splitter
num_points	irregular/partitioner.h	/^	int num_points;$/;"	m	class:Partitioner
num_points	irregular/reorder.h	/^	int num_points;$/;"	m	class:Reorder
num_points1	regular.h	/^        float num_points1 = ((float *)value1)[3];$/;"	l
num_points2	regular.h	/^        float num_points2 = ((float *)value2)[3];$/;"	l
num_points_per_part	irregular/partitioner.cpp	/^        int num_points_per_part = ceil((double)total\/partitions[dim]);$/;"	l
num_points_per_part	irregular/reorder.cpp	/^	int num_points_per_part = ceil((double)total\/partitions[dim]);$/;"	l
num_procs	lib/grid_view.h	/^	int num_procs;$/;"	m	class:Grid_view
num_procs	main2.cpp	/^  	int num_procs;$/;"	l
num_procs_	irregular/irregular_runtime.h	/^	int num_procs_;$/;"	m	class:IrregularRuntime
num_procs_	irregular/partition_view.h	/^	int num_procs_;$/;"	m	class:partition_view
num_procs_	regular/regular_runtime.h	/^	int num_procs_;$/;"	m	class:RegularRuntime
num_procs_	regular/splitter.h	/^		int num_procs_;		$/;"	m	class:splitter
num_tiles	lib/compute_cpu.cpp	/^	int num_tiles = tiles.size();$/;"	l
number_edges	irregular/cpu_kernel.cu	/^    int number_edges = p_cpu->my_num_edges();$/;"	l
number_parts	irregular/cpu_kernel.cu	/^    int number_parts = p_cpu->my_num_parts();$/;"	l
numflag	misc.c	/^    int numflag = 0, wgtflag = 0, edgecut;$/;"	l
nupdate	moldyn.cu	/^  int      nupdate = 0;$/;"	l
nvtxs	metis.h	/^  int nvtxs, nedges;		\/* The # of vertices and edges in the graph *\/$/;"	m	struct:graphdef
nvwgt	metis.h	/^  float *nvwgt;			\/* Normalized vertex weights *\/$/;"	m	struct:graphdef
object	irregular/cpu_kernel.cu	/^    Cobject *object = &(runtime->roc_)[tid];$/;"	l
object	lib/stencil_runtime.cu	/^	void *object = ((void **)arg)[2];$/;"	l
object_s	irregular/gpu_kernel.cu	/^    __shared__ Sobject object_s;$/;"	l
object_s	regular/gpu_kernel.cu	/^    __shared__ char object_s[SHARED_SIZE];$/;"	l
objects	regular/cpu_kernel.cu	/^    CO *objects = runtime->roc_;$/;"	l
offset	lib/CU_DS.h	/^	int offset[3];$/;"	m	struct:linear_tile
offset	lib/DS.h	/^	IndexArray offset;$/;"	m	struct:Tile
offset	lib/compute_cuda.cu	/^		int offset[3];		$/;"	l
offset	lib/data_util.cpp	/^    		IndexArray &offset = *oit;$/;"	l
offset	lib/grid_mpi.cu	/^                dst, offset, my_size());$/;"	l
offset	lib/grid_util.cc	/^    IndexArray &offset = *oit;$/;"	l
offset	lib/grid_view.cpp	/^		int offset = 0;$/;"	l
offset	lib/grid_view.cpp	/^	int offset = 1;$/;"	l
offset	regular/data_partition_mpi.h	/^	Offset *offset(){return offsets_;}$/;"	f	class:data_partition_mpi
offset	regular/data_type.h	/^	int offset;		$/;"	m	struct:element_t
offset	regular/roc.cu	/^    unsigned offset = __sync_fetch_and_add(&memory_offset, size); $/;"	l
offset	regular/rog.cu	/^	unsigned int offset = atomicAdd(&global_object_offset[gid_g], size);$/;"	l
offset	regular/ros.cu	/^	unsigned int offset = atomicAdd(&memory_offset, size);$/;"	l
offset_1d	lib/compute_cpu.cpp	/^	size_t offset_1d = 0;$/;"	l
offset_1d	lib/data_util.cpp	/^	size_t offset_1d = 0;$/;"	l
offset_1d	lib/grid_util.cc	/^  size_t offset_1d = 0;$/;"	l
offset_buffer_d_	regular/regular_runtime.h	/^	Offset **offset_buffer_d_;$/;"	m	class:RegularRuntime
offset_new	lib/data_util.cpp	/^	IndexArray offset_new;$/;"	l
offset_number	regular/cpu_kernel.cu	/^    int offset_number = runtime->dp_mpi_->num_offsets();$/;"	l
offset_number_	regular/data_partition_mpi.h	/^	int offset_number_;$/;"	m	class:data_partition_mpi
offset_pin	regular/data_partition_mpi.h	/^	Offset *offset_pin(){return offsets_pin_;}$/;"	f	class:data_partition_mpi
offset_tmp	lib/compute_cpu.cpp	/^	IndexArray offset_tmp;$/;"	l
offsets	km.cu	/^    	Offset *offsets = (Offset *)malloc(sizeof(Offset)*BSIZE);$/;"	l
offsets	lib/data_util.cpp	/^  	std::list<IndexArray> *offsets = new std::list<IndexArray>;$/;"	l
offsets	lib/grid_util.cc	/^  std::list<IndexArray> *offsets = new std::list<IndexArray>;$/;"	l
offsets	lib/grid_view.h	/^	int **offsets; 		\/\/offset info for sub-grid on each processor$/;"	m	class:Grid_view
offsets	regular/roc.h	/^	unsigned int offsets[GPU_BLOCKS*GPU_THREADS\/WARP_SIZE];$/;"	m	struct:roc
offsets	regular/rog.h	/^		unsigned int offsets[GPU_BLOCKS*GPU_THREADS\/WARP_SIZE];$/;"	m	struct:Reduction_Object_GPU
offsets_	regular/data_partition_mpi.h	/^	Offset *offsets_;$/;"	m	class:data_partition_mpi
offsets_	regular/regular_runtime.h	/^	Offset *offsets_;$/;"	m	class:RegularRuntime
offsets_	regular/splitter.h	/^		Offset *offsets_;$/;"	m	class:splitter
offsets_new	lib/data_util.cpp	/^  	std::list<IndexArray> *offsets_new = new std::list<IndexArray>;$/;"	l
offsets_new	lib/grid_util.cc	/^  std::list<IndexArray> *offsets_new = new std::list<IndexArray>;$/;"	l
offsets_pin_	regular/data_partition_mpi.h	/^	Offset *offsets_pin_;$/;"	m	class:data_partition_mpi
offsets_pin_	regular/regular_runtime.h	/^	Offset *offsets_pin_;$/;"	m	class:RegularRuntime
oflags	metis.h	/^  int oflags;$/;"	m	struct:controldef
oget_address	regular/rog.cu	/^__device__ void * Reduction_Object_GPU::oget_address(unsigned int index)$/;"	f	class:Reduction_Object_GPU
oget_address	regular/ros.cu	/^__device__ void * Reduction_Object::oget_address(unsigned short index)$/;"	f	class:Reduction_Object
oldstr	misc.c	/^  char *line, *oldstr, *newstr;$/;"	l
oma_init	regular/rog.cu	/^__device__ void Reduction_Object_GPU::oma_init()$/;"	f	class:Reduction_Object_GPU
oma_init	regular/ros.cu	/^__device__ void Reduction_Object::oma_init(int gid, int group_size)$/;"	f	class:Reduction_Object
omalloc	regular/roc.cu	/^unsigned roc::omalloc(unsigned int size)$/;"	f	class:roc
omalloc	regular/rog.cu	/^__device__ int Reduction_Object_GPU::omalloc(unsigned int size)$/;"	f	class:Reduction_Object_GPU
omalloc	regular/ros.cu	/^__device__ short Reduction_Object::omalloc(unsigned int size)$/;"	f	class:Reduction_Object
omit_localedges	misc.c	/^omit_localedges(int *from, int *ptnr, int n_nodes)$/;"	f
operator !=	lib/array.h	/^  bool operator!=(const ty &x) const {$/;"	f	class:IntegerArray
operator *	lib/array.h	/^  IntegerArray<ty> operator*(const ty &x) const {$/;"	f	class:IntegerArray
operator *=	lib/array.h	/^  IntegerArray<ty> &operator*=(const IntegerArray<ty> &x) {$/;"	f	class:IntegerArray
operator +	lib/array.h	/^  IntegerArray<ty> operator+(const IntegerArray<ty> &x) const {$/;"	f	class:IntegerArray
operator +	lib/array.h	/^  IntegerArray<ty> operator+(const ty &x) const {$/;"	f	class:IntegerArray
operator +=	lib/array.h	/^  IntegerArray<ty> &operator+=(const IntegerArray<ty> &x) {$/;"	f	class:IntegerArray
operator -	lib/array.h	/^  IntegerArray<ty> operator-(const IntegerArray<ty> &x) const {$/;"	f	class:IntegerArray
operator -	lib/array.h	/^  IntegerArray<ty> operator-(const ty &x) const {$/;"	f	class:IntegerArray
operator -=	lib/array.h	/^  IntegerArray<ty> &operator-=(const IntegerArray<ty> &x) {$/;"	f	class:IntegerArray
operator /	lib/array.h	/^  IntegerArray<ty> operator\/(const ty &x) const {$/;"	f	class:IntegerArray
operator /=	lib/array.h	/^  IntegerArray<ty> &operator\/=(const IntegerArray<ty> &x) {$/;"	f	class:IntegerArray
operator <	lib/array.h	/^  bool operator<(const ty &x) const {$/;"	f	class:IntegerArray
operator <<	lib/array.h	/^inline std::ostream &operator<<($/;"	f
operator <<	lib/array.h	/^inline std::ostream &operator<<(std::ostream &os,$/;"	f
operator <<	lib/util.h	/^  std::ostringstream &operator<< (const T &s) {$/;"	f	class:StringJoin
operator <<	lib/util.h	/^inline std::ostream &operator<<(std::ostream &os, const StringJoin &sj)$/;"	f
operator <=	lib/array.h	/^  bool operator<=(const ty &x) const {$/;"	f	class:IntegerArray
operator =	lib/array.h	/^  IntegerArray<ty> operator=(const IntegerArray<ty2> x) {$/;"	f	class:IntegerArray
operator ==	lib/array.h	/^  bool operator==(const ty &x) const {$/;"	f	class:IntegerArray
operator >	lib/array.h	/^  bool operator>(const ty &x) const {$/;"	f	class:IntegerArray
operator >=	lib/array.h	/^  bool operator>=(const ty &x) const {$/;"	f	class:IntegerArray
options	misc.c	/^    int nparts, options[10];$/;"	l
optype	metis.h	/^  int optype;			\/* Type of operation *\/$/;"	m	struct:controldef
org_cutoff	moldyn.cu	/^   double org_cutoff;$/;"	l
org_ind	misc.c	/^    int  *org_ind = ind;$/;"	l
org_neighUpdate	moldyn.cu	/^   int i, org_neighUpdate;$/;"	l
outgoing_reduction_array	irregular/reduction_array.h	/^class outgoing_reduction_array:public reduction_array$/;"	c
output	lib/compute_cpu.cpp	/^	char *output = grid->data_out();$/;"	l
output	regular/data_type.h	/^struct output$/;"	s
output_keys	regular/data_type.h	/^    char *output_keys;$/;"	m	struct:output
output_vals	regular/data_type.h	/^    char *output_vals;$/;"	m	struct:output
p	lib/buffer.cpp	/^	void *p = calloc(elm_size_, s);$/;"	l
p	lib/grid_mpi.cu	/^    		char *p = data_[0] + GridCalcOffset3D(halo_offset, my_real_size_) * unit_size_;$/;"	l
p	lib/grid_util.cc	/^  void *p = (void *)(subgrid_original +$/;"	l
p	misc.c	/^     int i, j, k, ntimes, r1, r2, *ind2, *p;$/;"	l
p	misc.c	/^     int i, ntimes, r1, r2, *ind=NULL, *ind2=NULL, *p;$/;"	l
p	misc.c	/^    int  i, j, k, p, n = 0;$/;"	l
p	misc.c	/^    int  i, j, k, p, q, n = 0;$/;"	l
p	misc.c	/^    int  i, j, k, t, n_pieces, root, root2, p, done, iter, real_i;$/;"	l
p	misc.c	/^    int i, *count, *count2, *tmp, *tmp2, *p;$/;"	l
p	misc.c	/^    int i, j, k, degree, max, root=0, p, cur, last, reverse = 1;$/;"	l
p	misc.c	/^    int i, p, lb, ub, pt, bp, ip, jp, localI, localP;$/;"	l
p1	input/gen.c	/^    int i, p1, p2, cut_edge = 0;$/;"	l
p2	input/gen.c	/^    int i, p1, p2, cut_edge = 0;$/;"	l
p_cpu	irregular/cpu_kernel.cu	/^    partition_cpu *p_cpu = runtime->p_cpu_;$/;"	l
p_cpu_	irregular/irregular_runtime.cu	/^		delete p_cpu_;$/;"	l
p_cpu_	irregular/irregular_runtime.cu	/^	delete p_cpu_;$/;"	l
p_cpu_	irregular/irregular_runtime.h	/^	partition_cpu *p_cpu_;$/;"	m	class:IrregularRuntime
p_cuda_	irregular/irregular_runtime.cu	/^			delete p_cuda_[i];$/;"	l
p_cuda_	irregular/irregular_runtime.cu	/^	delete [] p_cuda_;$/;"	l
p_cuda_	irregular/irregular_runtime.h	/^	partition_cuda **p_cuda_;$/;"	m	class:IrregularRuntime
p_mpi_	irregular/irregular_runtime.cu	/^	delete p_mpi_;$/;"	l
p_mpi_	irregular/irregular_runtime.h	/^	partition_mpi *p_mpi_;$/;"	m	class:IrregularRuntime
p_node_data	irregular/partition_view.cpp	/^	char *p_node_data = (char *)p->my_node_data(); $/;"	l
pa	irregular.h	/^		struct para *pa = (struct para *)parameter;$/;"	l
pa	moldyn.cu	/^     struct para pa;$/;"	l
padding	lib/grid_cuda.cu	/^	int padding = (global_real_size[num_dims_ - 1] - global_size[num_dims_ - 1])\/2;$/;"	l
pairs_per_bucket	irregular/roc.h	/^	int pairs_per_bucket[NUM_BUCKETS_G];$/;"	m	struct:Reduction_Object_C
pairs_per_bucket	irregular/rog.h	/^	int pairs_per_bucket[NUM_BUCKETS_G];$/;"	m	struct:Reduction_Object_G
pairs_per_bucket	regular/roc.h	/^        unsigned int pairs_per_bucket[NUM_BUCKETS_G];$/;"	m	struct:roc
pairs_per_bucket	regular/rog.h	/^		unsigned int pairs_per_bucket[NUM_BUCKETS_G];$/;"	m	struct:Reduction_Object_GPU
para	moldyn.h	/^struct para$/;"	s
parameter	irregular/cpu_kernel.cu	/^    void *parameter = runtime->parameter_;$/;"	l
parameter_	irregular/irregular_runtime.h	/^	void *parameter_;$/;"	m	class:IrregularRuntime
parameter_	regular/regular_runtime.h	/^	void *parameter_;	$/;"	m	class:RegularRuntime
parameter_d_	irregular/irregular_runtime.cu	/^			parameter_d_[i],$/;"	l
parameter_d_	irregular/irregular_runtime.h	/^	void **parameter_d_;$/;"	m	class:IrregularRuntime
parameter_d_	regular/regular_runtime.h	/^	void **parameter_d_;$/;"	m	class:RegularRuntime
parameter_size_	irregular/irregular_runtime.h	/^	int parameter_size_;$/;"	m	class:IrregularRuntime
parameter_size_	regular/regular_runtime.h	/^	int parameter_size_;$/;"	m	class:RegularRuntime
parameter_size_	regular/splitter.h	/^		int parameter_size_;$/;"	m	class:splitter
parameters_	regular/splitter.h	/^		void *parameters_;$/;"	m	class:splitter
part	irregular/data_type.h	/^struct part$/;"	s
part	irregular/partition_view.cpp	/^	partition_mpi *part = new partition_mpi($/;"	l
part	misc.c	/^    int npart, *part, *ind2;		\/* beginning of a part *\/$/;"	l
part_id	irregular/data_type.h	/^	int part_id;$/;"	m	struct:part
part_id	irregular/gpu_kernel.cu	/^    		int part_id = parts[j].part_id;$/;"	l
part_index	irregular/cpu_kernel.cu	/^    int *part_index = runtime->part_index;$/;"	l
part_index	irregular/irregular_runtime.h	/^	int *part_index;$/;"	m	class:IrregularRuntime
part_index	irregular/partitioner.h	/^	int *part_index;$/;"	m	class:Partitioner
part_index	irregular/reorder.h	/^	int *part_index;$/;"	m	class:Reorder
part_index_d	irregular/irregular_runtime.cu	/^			part_index_d,$/;"	l
part_index_d	irregular/irregular_runtime.h	/^	int *part_index_d;	$/;"	m	class:IrregularRuntime
part_sz	misc.c	/^    int L1_cache, part_sz; $/;"	l
part_x	irregular/partitioner.cpp	/^	int part_x, part_y;$/;"	l
part_y	irregular/partitioner.cpp	/^	int part_x, part_y;$/;"	l
partition	irregular/partition.h	/^	partition(int my_num_nodes, $/;"	f	class:partition
partition	irregular/partition.h	/^class partition$/;"	c
partition	irregular/reorder.cpp	/^void  Reorder::partition(T *coordinates)$/;"	f	class:Reorder
partition	lib/grid_view.cpp	/^static void partition(int num_dims, int num_procs, const IndexArray &size, $/;"	f	file:
partition_a_dim	irregular/partitioner.cpp	/^int Partitioner::partition_a_dim(T *coordinates, int dim, int p, int r)$/;"	f	class:Partitioner
partition_a_dim	irregular/reorder.cpp	/^int  Reorder::partition_a_dim(T *coordinates, int dim, int p, int r)$/;"	f	class:Reorder
partition_args	irregular/partitioner.h	/^struct partition_args$/;"	s
partition_cpu	irregular/partition_cpu.h	/^		partition_cpu(IRIndex  my_num_nodes, $/;"	f	class:partition_cpu
partition_cpu	irregular/partition_cpu.h	/^class partition_cpu:public partition$/;"	c
partition_cuda	irregular/partition_cuda.h	/^		partition_cuda(IRIndex my_num_nodes, $/;"	f	class:partition_cuda
partition_cuda	irregular/partition_cuda.h	/^class partition_cuda:public partition$/;"	c
partition_device_nodes	irregular/partitioner.cpp	/^void Partitioner::partition_device_nodes(T *coordinates)$/;"	f	class:Partitioner
partition_mpi	irregular/partition_mpi.h	/^	partition_mpi($/;"	f	class:partition_mpi
partition_mpi	irregular/partition_mpi.h	/^class partition_mpi:public partition$/;"	c
partition_points	irregular/partitioner.cpp	/^void Partitioner::partition_points(T *coordinates, int *partitions, int dim, int start, int end)$/;"	f	class:Partitioner
partition_points	irregular/reorder.cpp	/^void Reorder::partition_points(T *coordinates, int dim, int start, int end)$/;"	f	class:Reorder
partition_view	irregular/partition_view.cpp	/^partition_view::partition_view(int num_procs, $/;"	f	class:partition_view
partition_view	irregular/partition_view.h	/^class partition_view$/;"	c
partitioner_	irregular/irregular_runtime.h	/^	Reorder *partitioner_;$/;"	m	class:IrregularRuntime
partitions	irregular/irregular_runtime.cu	/^	int *partitions = (int *)malloc(sizeof(int)*node_num_dims_);$/;"	l
partitions	irregular/reorder.h	/^	int *partitions;$/;"	m	class:Reorder
partitions	lib/grid_view.h	/^	int **partitions;  	\/\/partition info for sub-grid on each processor$/;"	m	class:Grid_view
partnercomp	misc.c	/^static int partnercomp (const void *i, const void *j)$/;"	f	file:
partners	misc.c	/^     int n_nodes, n_edges, *partners, *from, n;$/;"	l
partners	misc.c	/^    int  *partners, *from;$/;"	l
partners	misc.c	/^    int *partners, *from;$/;"	l
partners	misc.c	/^   int n_nodes, n_edges, *partners, *from, n, unit_sz, i, apply;$/;"	l
parts	irregular/cpu_kernel.cu	/^    Part *parts = p_cpu->my_parts();$/;"	l
parts	irregular/reorder.h	/^	Part *parts;$/;"	m	class:Reorder
pass	misc.c	/^    int  pass, npass, nshift;$/;"	l
peer_nodes_start_number	irregular/partition_mpi.h	/^	int *peer_nodes_start_number(){return peer_nodes_start_number_;}$/;"	f	class:partition_mpi
peer_nodes_start_number_	irregular/partition_mpi.h	/^	int *peer_nodes_start_number_;$/;"	m	class:partition_mpi
peer_request_node_data_	irregular/partition_view.h	/^	void **peer_request_node_data_;$/;"	m	class:partition_view
peer_request_nodes_	irregular/partition_view.h	/^	int **peer_request_nodes_;$/;"	m	class:partition_view
peer_request_num_nodes_	irregular/partition_view.h	/^	int *peer_request_num_nodes_;$/;"	m	class:partition_view
peer_request_num_nodes_sum_	irregular/partition_view.h	/^	int *peer_request_num_nodes_sum_;$/;"	m	class:partition_view
percent	misc.c	/^     double percent;$/;"	l
percent	moldyn.cu	/^  double   ekin, percent;$/;"	l
perturb	input/gen.c	/^double   perturb;               \/*  perturbs initial coordinates          *\/$/;"	v
perturb	moldyn.cu	/^         perturb,               \/*  perturbs initial coordinates          *\/$/;"	v
perturb	moldyn.h	/^         perturb,               \/*  perturbs initial coordinates          *\/ $/;"	v
pfactor	metis.h	/^  int pfactor;			\/* .1*prunning factor *\/$/;"	m	struct:controldef
pgainspan	metis.h	/^  int pgainspan, ngainspan;     \/* plus and negative gain span *\/$/;"	m	struct:PQueueType
pid	metis.h	/^  idxtype pid;$/;"	m	struct:edegreedef
pid	metis.h	/^  idxtype pid;$/;"	m	struct:vedegreedef
pmat	metis.h	/^  idxtype *pmat;			\/* An array of k^2 used for eliminating domain $/;"	m	struct:workspacedef
point_data	irregular/cpu_kernel.cu	/^    void *point_data = p_cpu->my_node_data();$/;"	l
point_data	moldyn.h	/^struct point_data$/;"	s
points	km.cu	/^    	float *points = (float *)malloc(sizeof(float)*KMEANS_DIM*BSIZE);$/;"	l
points	moldyn.h	/^	double points[3];$/;"	m	struct:point_data
points_per_partition	irregular/reorder.cpp	/^		int points_per_partition = ceil((double)num_points\/total_num_partitions);$/;"	l
pos	irregular/partitioner.cpp	/^                int pos = random_select(coordinates, dim, st, end, num_points_per_part);$/;"	l
pos	irregular/reorder.cpp	/^		int pos = random_select(coordinates, dim, st, end, num_points_per_part);				$/;"	l
pos_map	irregular/partition_view.cpp	/^	map<int, int> **pos_map = (map<int, int> **)malloc(sizeof(map<int, int>*)*num_procs_);;$/;"	l
pos_map	irregular/partitioner.h	/^	int *pos_map; \/\/used to record the change of position of points$/;"	m	class:Partitioner
pos_map	irregular/reorder.h	/^	int *pos_map; \/\/used to record the change of position of points$/;"	m	class:Reorder
pres	moldyn.cu	/^ double ek, etot, temp, pres, rp, tscale ;$/;"	l
prev	input/gen.c	/^  int    i, j, prev;$/;"	l
prev	metis.h	/^  struct ListNodeType *prev, *next;     \/* It's a doubly-linked list *\/$/;"	m	struct:ListNodeType	typeref:struct:ListNodeType::ListNodeType
prev_lap_time	misc.c	/^static double prev_lap_time = 0.0;$/;"	v	file:
prev_time	moldyn.cu	/^  double   init_time, prev_time = 0.0, tmp_time, update_time = 0.0;$/;"	l
print	lib/array.h	/^  std::ostream& print(std::ostream &os) const {$/;"	f	class:IntegerArray
print_grid	lib/test/test_util.h	/^std::ostream& print_grid(GridMPI *g, int my_rank, std::ostream &os) {$/;"	f
print_map	irregular/reorder.cpp	/^void    Reorder::print_map(T *coordinates)$/;"	f	class:Reorder
print_stats	input/gen.c	/^print_stats()$/;"	f
proc0	irregular/partition_view.cpp	/^		int proc0 = get_proc_id(idx0, global_num_nodes_, num_procs_);$/;"	l
proc0	irregular/partition_view.cpp	/^	int idx0, idx1, proc0, proc1;$/;"	l
proc1	irregular/partition_view.cpp	/^		int proc1 = get_proc_id(idx1, global_num_nodes_, num_procs_);$/;"	l
proc1	irregular/partition_view.cpp	/^	int idx0, idx1, proc0, proc1;$/;"	l
proc_indices	lib/grid_view.h	/^	std::vector<IndexArray> proc_indices;$/;"	m	class:Grid_view
proc_num_dims	lib/grid_view.h	/^	int proc_num_dims;	\/\/organization of processes$/;"	m	class:Grid_view
proc_num_dims_	lib/stencil_creator.h	/^	int proc_num_dims_;$/;"	m	class:StencilCreator
proc_num_dims_	lib/stencil_runtime.h	/^	int proc_num_dims_;$/;"	m	class:StencilRuntime
proc_size	lib/grid_view.h	/^	IndexArray proc_size;   \/\/organization of processes$/;"	m	class:Grid_view
proc_size_	lib/stencil_creator.h	/^	IntArray proc_size_;$/;"	m	class:StencilCreator
proc_size_	lib/stencil_runtime.h	/^	IntArray proc_size_; $/;"	m	class:StencilRuntime
process_a_tile	lib/compute_cpu.cpp	/^void process_a_tile(int num_dims, int unit_size, void *input, void *output, struct Tile &tile, IndexArray &size)$/;"	f
process_border	lib/stencil_runtime.cu	/^void StencilRuntime::process_border()$/;"	f	class:StencilRuntime
process_internal	lib/stencil_runtime.cu	/^void StencilRuntime::process_internal()$/;"	f	class:StencilRuntime
procs	moldyn.cu	/^  int      tmp,procs,i,j,k,ii, start_time;$/;"	l
profile_iter	lib/stencil_runtime.cu	/^void StencilRuntime::profile_iter()$/;"	f	class:StencilRuntime
psize	misc.c	/^    int level, npart, psize, npass, nshift;$/;"	l
pt	misc.c	/^    int i, p, lb, ub, pt, bp, ip, jp, localI, localP;$/;"	l
ptnr2	misc.c	/^    int  *sort_ord, *from2, *from, *ptnr2;$/;"	l
ptnr2	misc.c	/^    int  *sort_ord, *from2, *ptnr2;$/;"	l
ptr	irregular/partition_view.cpp	/^			char *ptr = p_node_data + cur * node_data_elm_size_;$/;"	l
ptr	irregular/partition_view.cpp	/^	void *ptr = NULL;$/;"	l
ptr	lib/buffer_cuda.cu	/^  	void *ptr = NULL;  $/;"	l
ptr	misc.c	/^     byte *ptr, *tx=NULL;$/;"	l
ptr	misc.c	/^    byte *ptr, *tx = NULL;$/;"	l
ptr_d	irregular/partition_view.cpp	/^	void *ptr_d = NULL;$/;"	l
ptr_type	lib/stencil_runtime.cu	/^	int *ptr_type = (int *)((void **)arg)[1];	$/;"	l
pv_	irregular/irregular_runtime.cu	/^	delete pv_;$/;"	l
pv_	irregular/irregular_runtime.h	/^	partition_view *pv_;$/;"	m	class:IrregularRuntime
pwgts	metis.h	/^  idxtype *where, *pwgts;$/;"	m	struct:graphdef
q	irregular/partitioner.cpp	/^	int q = random_partition_a_dim(coordinates, dim, p, r);$/;"	l
q	irregular/reorder.cpp	/^	int q = random_partition_a_dim(coordinates, dim, p, r);$/;"	l
q	misc.c	/^    int  i, j, k, p, q, n = 0;$/;"	l
r	misc.c	/^     int r;$/;"	l
r	moldyn.cu	/^   double ekin, ts, sp, sc, r, s;$/;"	l
r1	misc.c	/^     int i, j, k, ntimes, r1, r2, *ind2, *p;$/;"	l
r1	misc.c	/^     int i, ntimes, r1, r2, *ind=NULL, *ind2=NULL, *p;$/;"	l
r148	irregular.h	/^		double rrd, rrd2, rrd3, rrd4, rrd6, rrd7, r148;$/;"	l
r2	misc.c	/^     int i, j, k, ntimes, r1, r2, *ind2, *p;$/;"	l
r2	misc.c	/^     int i, ntimes, r1, r2, *ind=NULL, *ind2=NULL, *p;$/;"	l
rand	moldyn.cu	/^      double  rand;$/;"	l
rand_num	misc.c	/^static int rand_num[50] = { \/* pre-generated random numbers *\/$/;"	v	file:
random_partition_a_dim	irregular/partitioner.cpp	/^int Partitioner::random_partition_a_dim(T *coordinates, int dim, int p, int r) $/;"	f	class:Partitioner
random_partition_a_dim	irregular/reorder.cpp	/^int Reorder::random_partition_a_dim(T *coordinates, int dim, int p, int r) $/;"	f	class:Reorder
random_select	irregular/partitioner.cpp	/^int Partitioner::random_select(T *coordinates, int dim, int p, int r, int i)$/;"	f	class:Partitioner
random_select	irregular/reorder.cpp	/^int  Reorder::random_select(T *coordinates, int dim, int p, int r, int i)$/;"	f	class:Reorder
randomize	input/gen.c	/^int      randomize = 0;$/;"	v
rank	irregular/reduction_array.h	/^	int rank(){return rank_;}$/;"	f	class:incoming_reduction_array
rank	irregular/reduction_array.h	/^	int rank(){return rank_;}$/;"	f	class:outgoing_reduction_array
rank	lib/grid_view.cpp	/^	int rank = 0;$/;"	l
rank_	irregular/partitioner.h	/^	int rank_;$/;"	m	class:Partitioner
rank_	irregular/reduction_array.h	/^	int rank_; \/\/the rank of the sender	$/;"	m	class:incoming_reduction_array
rank_	irregular/reduction_array.h	/^	int rank_; \/\/the rank of the sender	$/;"	m	class:outgoing_reduction_array
rank_in_proc	irregular/partition_view.cpp	/^			int rank_in_proc = (*pos_map[proc0])[idx0];\/\/distance(remote_nodes[proc0]->begin(), remote_nodes[proc0]->find(idx0)); $/;"	l
rank_in_proc	irregular/partition_view.cpp	/^			int rank_in_proc = (*pos_map[proc1])[idx1];\/\/distance(remote_nodes[proc1]->begin(), remote_nodes[proc1]->find(idx1)); $/;"	l
rcbprocess	misc.c	/^rcbprocess(int n_nodes, int n_edges, int (*el)[2], int n, long (*repos)[2])$/;"	f
rcbprocess2	misc.c	/^rcbprocess2(int n_nodes, int n_edges, int *partners, int *from, int n, long (*repos)[2])$/;"	f
rd	input/gen.c	/^    double sideHalf, cutoffSquare, rd, xx, yy, zz;$/;"	l
rd	input/gen.c	/^  double cutoffSquare, xx, yy, zz, rd;$/;"	l
rd	irregular.h	/^		double rd;$/;"	l
rd	moldyn.cu	/^	   double rd;$/;"	l
rd	moldyn.cu	/^    double sideHalf, cutoffSquare, rd, xx, yy, zz;$/;"	l
rdata	metis.h	/^  idxtype *gdata, *rdata;	\/* Memory pools for graph and refinement data.$/;"	m	struct:graphdef
re_init	irregular/irregular_runtime.cu	/^void IrregularRuntime::re_init()$/;"	f	class:IrregularRuntime
real_i	misc.c	/^    int  i, j, k, t, n_pieces, root, root2, p, done, iter, real_i;$/;"	l
reduce	irregular.h	/^	DEVICE void reduce(VALUE *value1, VALUE *value2)$/;"	f	namespace:FGPU
reduce	regular.h	/^DEVICE void reduce(void *value1, unsigned short value1_size, void *value2, unsigned short value2_size)$/;"	f	namespace:FFGPU
reduction_array	irregular/reduction_array.h	/^class reduction_array$/;"	c
reduction_elm_size	irregular/partition.h	/^	int reduction_elm_size(){return reduction_elm_size_;}$/;"	f	class:partition
reduction_elm_size_	irregular/irregular_runtime.h	/^	int reduction_elm_size_;$/;"	m	class:IrregularRuntime
reduction_elm_size_	irregular/partition.h	/^	int reduction_elm_size_;$/;"	m	class:partition
reduction_elm_size_	irregular/partition_view.h	/^	int reduction_elm_size_;$/;"	m	class:partition_view
reduction_elm_size_	irregular/partitioner.h	/^	int reduction_elm_size_;$/;"	m	class:Partitioner
reduction_output	regular/regular_runtime.h	/^	struct output reduction_output;$/;"	m	class:RegularRuntime	typeref:struct:RegularRuntime::output
reduction_result_	irregular/irregular_runtime.h	/^	void *reduction_result_;$/;"	m	class:IrregularRuntime
reduction_time	moldyn.cu	/^  double reduction_time = 0; $/;"	l
ref_offset	lib/compute_cpu.cpp	/^	size_t ref_offset = 1;$/;"	l
ref_offset	lib/data_util.cpp	/^	size_t ref_offset = 1;$/;"	l
ref_offset	lib/grid_util.cc	/^  size_t ref_offset = 1;$/;"	l
rehash	regular/ros.cu	/^	int rehash = 0;$/;"	l
release_lock	irregular/cpu_kernel_tools.cu	/^	void release_lock(volatile int *lock_value)$/;"	f
release_lock	irregular/gpu_kernel_tools.cu	/^	__device__ void release_lock(int *lockVal)$/;"	f
release_lock	regular/gpu_kernel_tools.cu	/^__device__ void release_lock(int *lockVal)$/;"	f
release_lock	regular/roc.cu	/^bool release_lock(volatile int *lock_value)$/;"	f
rem	lib/compute_cpu.cpp	/^	int rem = num_tiles - tiles_per_proc * CPU_THREADS;$/;"	l
rem	lib/grid_view.cpp	/^			int rem = size[i]%num_partitions[i];$/;"	l
remain	regular/cpu_kernel.cu	/^    int remain = 0;$/;"	l
remain	regular/regular_runtime.cu	/^			int remain = total_offsets - start;$/;"	l
remaining_buckets	irregular/ros.h	/^		int remaining_buckets;$/;"	m	struct:Reduction_Object_S
remaining_buckets	regular/ros.h	/^		int remaining_buckets;$/;"	m	struct:Reduction_Object
remote_node_sum_	irregular/partition_view.h	/^	int *remote_node_sum_;$/;"	m	class:partition_view
remote_nodes	irregular/partition_view.cpp	/^	map<int, int> **remote_nodes;$/;"	l
remote_nodes_array_	irregular/partition_view.h	/^	int **remote_nodes_array_;$/;"	m	class:partition_view
remote_num_nodes_	irregular/partition_view.h	/^	int *remote_num_nodes_;$/;"	m	class:partition_view
remove	regular/ros.cu	/^__device__ inline void Reduction_Object::remove(unsigned short bucket_index)$/;"	f	class:Reduction_Object
reorder_edges	irregular/reorder.cpp	/^void  Reorder::reorder_edges(EDGE *edges)$/;"	f	class:Reorder
reorder_satellite_data	irregular/partitioner.cpp	/^void Partitioner::reorder_satellite_data(void *satellite_data, int elm_size)$/;"	f	class:Partitioner
reorder_satellite_data	irregular/reorder.cpp	/^void   Reorder::reorder_satellite_data(void *satellite_data, int elm_size)$/;"	f	class:Reorder
req	irregular/partition_view.cpp	/^			MPI_Request req;	$/;"	l
req	irregular/partition_view.cpp	/^			MPI_Request req;$/;"	l
req	irregular/partition_view.cpp	/^		MPI_Request *req = &(requests[i]);	$/;"	l
req	lib/grid_view.cpp	/^  	  	MPI_Request *req = &(*it);$/;"	l
req	lib/grid_view.cpp	/^    		MPI_Request req;$/;"	l
req	lib/stencil_runtime.cu	/^			MPI_Request *req = &(requests[i][j]);	$/;"	l
requests	irregular/partition_view.cpp	/^	vector<MPI_Request> requests;$/;"	l
requests	lib/grid_view.cpp	/^  	std::vector<MPI_Request> requests;$/;"	l
requests	lib/stencil_runtime.h	/^	vector<MPI_Request> *requests;$/;"	m	class:StencilRuntime
reset_node_data	irregular/irregular_runtime.cu	/^void IrregularRuntime::reset_node_data(void *node_data)$/;"	f	class:IrregularRuntime
reset_timer	timer.c	/^void reset_timer()$/;"	f
reset_timer_	timer.c	/^void reset_timer_()$/;"	f
ret	irregular/partition_util.cpp	/^	int ret = node_id\/average;$/;"	l
ret	irregular/roc.cu	/^	bool ret = true;$/;"	l
ret	irregular/rog.cu	/^	bool ret = true;$/;"	l
ret	irregular/ros.cu	/^	bool ret = true;$/;"	l
ret	lib/array.h	/^    IntegerArray ret;$/;"	l
ret	lib/array.h	/^    IntegerArray<ty> ret;$/;"	l
ret	misc.c	/^    int ret = 0;$/;"	l
ret	regular/rog.cu	/^	bool ret = true;$/;"	l
ret	regular/ros.cu	/^	bool ret = true;$/;"	l
reuse_distance	misc.c	/^double reuse_distance(int n_nodes, int *partners, int *from)$/;"	f
reverse	misc.c	/^    int i, j, k, degree, max, root=0, p, cur, last, reverse = 1;$/;"	l
rinfo	metis.h	/^  RInfoType *rinfo;$/;"	m	struct:graphdef
rinfodef	metis.h	/^struct rinfodef {$/;"	s
roc	irregular/cpu_args.h	/^	Cobject *roc;	$/;"	m	struct:init_args
roc	regular/roc.h	/^struct roc$/;"	s
roc1	irregular/cpu_args.h	/^	Cobject *roc1;$/;"	m	struct:merge_args
roc2	irregular/cpu_args.h	/^	Cobject *roc2;$/;"	m	struct:merge_args
roc_	irregular/irregular_runtime.h	/^        Cobject *roc_;	\/\/cpu reduction objects$/;"	m	class:IrregularRuntime
roc_	regular/regular_runtime.h	/^	CO *roc_;$/;"	m	class:RegularRuntime
rog_	irregular/irregular_runtime.cu	/^			rog_[i]$/;"	l
rog_	irregular/irregular_runtime.cu	/^	delete [] rog_;$/;"	l
rog_	irregular/irregular_runtime.h	/^        Gobject **rog_; \/\/gpu reduction objects$/;"	m	class:IrregularRuntime
rog_	regular/regular_runtime.h	/^	GO **rog_;$/;"	m	class:RegularRuntime
rogh	irregular/irregular_runtime.cu	/^	Gobject *rogh = (Gobject *)malloc(sizeof(Gobject));$/;"	l
rogh	regular/regular_runtime.cu	/^	GO *rogh = (GO *)malloc(sizeof(GO));$/;"	l
root	misc.c	/^    int  i, j, k, t, n_pieces, root, root2, p, done, iter, real_i;$/;"	l
root	misc.c	/^    int i, j, k, degree, max, root=0, p, cur, last, reverse = 1;$/;"	l
root2	misc.c	/^    int  i, j, k, t, n_pieces, root, root2, p, done, iter, real_i;$/;"	l
roundup	misc.c	2487;"	d	file:
rp	moldyn.cu	/^ double ek, etot, temp, pres, rp, tscale ;$/;"	l
rrd	irregular.h	/^		double rrd, rrd2, rrd3, rrd4, rrd6, rrd7, r148;$/;"	l
rrd2	irregular.h	/^		double rrd, rrd2, rrd3, rrd4, rrd6, rrd7, r148;$/;"	l
rrd3	irregular.h	/^		double rrd, rrd2, rrd3, rrd4, rrd6, rrd7, r148;$/;"	l
rrd4	irregular.h	/^		double rrd, rrd2, rrd3, rrd4, rrd6, rrd7, r148;$/;"	l
rrd6	irregular.h	/^		double rrd, rrd2, rrd3, rrd4, rrd6, rrd7, r148;$/;"	l
rrd7	irregular.h	/^		double rrd, rrd2, rrd3, rrd4, rrd6, rrd7, r148;$/;"	l
rtclock	lib/time_util.cpp	/^double rtclock() \/\/return the clock$/;"	f
runtime	irregular/cpu_args.h	/^    IrregularRuntime *runtime;$/;"	m	struct:cpu_args
runtime	irregular/cpu_kernel.cu	/^    IrregularRuntime *runtime = args->runtime; $/;"	l
runtime	irregular/irregular_runtime.cu	/^	IrregularRuntime *runtime = (IrregularRuntime *)arg;$/;"	l
runtime	lib/compute_cpu.cpp	/^	StencilRuntime *runtime = args->runtime;$/;"	l
runtime	lib/cpu_util.h	/^	StencilRuntime *runtime;$/;"	m	struct:cargs
runtime	lib/stencil_runtime.cu	/^	StencilRuntime *runtime = (StencilRuntime *)object;$/;"	l
runtime	regular/args.h	/^	RegularRuntime *runtime;$/;"	m	struct:cpu_args_reg
runtime	regular/args.h	/^	RegularRuntime *runtime;$/;"	m	struct:gpu_args_reg
runtime	regular/cpu_kernel.cu	/^    RegularRuntime *runtime = args->runtime; $/;"	l
runtime	regular/regular_runtime.cu	/^	RegularRuntime *runtime = (RegularRuntime *)arg;	$/;"	l
s	lib/buffer.cpp	/^	size_t s = size.accumulate(num_dims_);$/;"	l
s	lib/buffer_cuda.cu	/^	size_t s = size.accumulate(num_dims_); $/;"	l
s	lib/util.h	/^    ss << s;$/;"	l
s	misc.c	/^    int s = 0;$/;"	l
s	moldyn.cu	/^   double ekin, ts, sp, sc, r, s;$/;"	l
s	regular/cpu_kernel_tools.cu	/^	         const char *s = (const char *)src;$/;"	l
s	regular/gpu_kernel_tools.cu	/^         const char *s=(const char *)src;$/;"	l
s:cpo_save	Session.vim	/^let s:cpo_save=&cpo$/;"	v
s:cpo_save	input/Session.vim	/^let s:cpo_save=&cpo$/;"	v
s:cpo_save	lib/Session.vim	/^let s:cpo_save=&cpo$/;"	v
s:l	Session.vim	/^let s:l = 51 - ((11 * winheight(0) + 25) \/ 51)$/;"	v
s:l	input/Session.vim	/^let s:l = 149 - ((50 * winheight(0) + 25) \/ 51)$/;"	v
s:l	lib/Session.vim	/^let s:l = 57 - ((50 * winheight(0) + 25) \/ 51)$/;"	v
s:so_save	Session.vim	/^let s:so_save = &so | let s:siso_save = &siso | set so=0 siso=0$/;"	v
s:so_save	input/Session.vim	/^let s:so_save = &so | let s:siso_save = &siso | set so=0 siso=0$/;"	v
s:so_save	lib/Session.vim	/^let s:so_save = &so | let s:siso_save = &siso | set so=0 siso=0$/;"	v
s:sx	Session.vim	/^let s:sx = expand("<sfile>:p:r")."x.vim"$/;"	v
s:sx	input/Session.vim	/^let s:sx = expand("<sfile>:p:r")."x.vim"$/;"	v
s:sx	lib/Session.vim	/^let s:sx = expand("<sfile>:p:r")."x.vim"$/;"	v
s:wipebuf	Session.vim	/^  let s:wipebuf = bufnr('%')$/;"	v
s:wipebuf	input/Session.vim	/^  let s:wipebuf = bufnr('%')$/;"	v
s:wipebuf	lib/Session.vim	/^  let s:wipebuf = bufnr('%')$/;"	v
satellite_data_back	irregular/partitioner.cpp	/^	void *satellite_data_back = malloc(elm_size * num_points);		$/;"	l
satellite_data_back	irregular/reorder.cpp	/^	void *satellite_data_back = malloc(elm_size * num_points);		$/;"	l
sc	moldyn.cu	/^   double ekin, ts, sp, sc, r, s;$/;"	l
sdims	lib/compute_cuda.cu	/^	__shared__ int sdims[3];$/;"	l
second	irregular/partition_view.cpp	/^			int second = it->second;$/;"	l
send_to_neighbors	lib/grid_cpu.cpp	/^void GridCPU::send_to_neighbors(int dim, int stencil_width, GridMPI *grid_global, GridCuda **grid_cuda)$/;"	f	class:GridCPU
send_to_neighbors	lib/grid_cuda.cu	/^void GridCuda::send_to_neighbors(int dim, int stencil_width, GridMPI *grid_global, GridCPU *grid_cpu, GridCuda **grid_cuda)$/;"	f	class:GridCuda
sep	lib/util.h	/^    if (!first) ss << sep;$/;"	l
sep	lib/util.h	/^  const std::string sep;$/;"	m	class:StringJoin
set_device_id	lib/grid_cuda.cu	/^void GridCuda::set_device_id(int id)$/;"	f	class:GridCuda
set_num_devices	lib/grid_cpu.cpp	/^void GridCPU::set_num_devices(int num_devices)$/;"	f	class:GridCPU
set_num_devices	lib/grid_cuda.cu	/^void GridCuda::set_num_devices(int num_devices)$/;"	f	class:GridCuda
set_timer	timer.c	/^void set_timer()$/;"	f
set_timer_	timer.c	/^void set_timer_()$/;"	f
side	input/gen.c	/^double   side;                  \/*  length of side of box                 *\/$/;"	v
side	irregular.h	/^		double side = pa->side;$/;"	l
side	moldyn.cu	/^double   side,                  \/*  length of side of box                 *\/$/;"	v
side	moldyn.h	/^	double side;	$/;"	m	struct:para
side	moldyn.h	/^double   side,                  \/*  length of side of box                 *\/ $/;"	v
sideHalf	input/gen.c	/^    double sideHalf, cutoffSquare, rd, xx, yy, zz;$/;"	l
sideHalf	input/gen.c	/^double   sideHalf;              \/*  1\/2 of side                           *\/$/;"	v
sideHalf	irregular.h	/^		double sideHalf = 0.5 * side;$/;"	l
sideHalf	moldyn.cu	/^         sideHalf,              \/*  1\/2 of side                           *\/$/;"	v
sideHalf	moldyn.cu	/^    double sideHalf, cutoffSquare, rd, xx, yy, zz;$/;"	l
sideHalf	moldyn.h	/^         sideHalf,              \/*  1\/2 of side                           *\/$/;"	v
sim_off	input/gen.c	/^sim_off(){}$/;"	f
sim_on	input/gen.c	/^sim_on(){}$/;"	f
sim_stats	input/gen.c	/^sim_stats(){}$/;"	f
siz	input/gen.c	/^ int siz = boxSize, siz_3;$/;"	l
siz	misc.c	/^     int  siz, siz0 = 0, coordi_swap;$/;"	l
siz	misc.c	/^     int  siz, siz0 = 0;$/;"	l
siz	misc.c	/^    int *ind, i, siz, siz0 = 0; $/;"	l
siz	moldyn.cu	/^ int siz = boxSize, siz_3;$/;"	l
siz0	misc.c	/^     int  siz, siz0 = 0, coordi_swap;$/;"	l
siz0	misc.c	/^     int  siz, siz0 = 0;$/;"	l
siz0	misc.c	/^    int *ind, i, siz, siz0 = 0; $/;"	l
siz_3	input/gen.c	/^ int siz = boxSize, siz_3;$/;"	l
siz_3	moldyn.cu	/^ int siz = boxSize, siz_3;$/;"	l
size	lib/CU_DS.h	/^	int size[3];$/;"	m	struct:linear_tile
size	lib/DS.h	/^	IndexArray size;$/;"	m	struct:Tile
size	lib/buffer.h	/^	IndexArray &size() {return size_;}$/;"	f	class:Buffer
size	lib/data_util.cpp	/^  	size_t size = subgrid_size.accumulate(num_dims) * elm_size;$/;"	l
size	lib/grid.h	/^	const IndexArray &size() const$/;"	f	class:Grid
size	lib/grid_cpu.cpp	/^	IndexArray size = my_real_size();		$/;"	l
size	lib/grid_cuda.cu	/^			IndexArray size = my_real_size_; $/;"	l
size	lib/grid_cuda.cu	/^		IndexArray size = my_real_size();$/;"	l
size	lib/grid_cuda.cu	/^	IndexArray size = my_real_size();$/;"	l
size	lib/grid_mpi.cu	/^			IndexArray size = my_real_size_;$/;"	l
size	lib/grid_mpi.cu	/^      			IndexArray size = my_real_size_; $/;"	l
size	lib/grid_util.cc	/^  size_t size = $/;"	l
size	lib/stencil_runtime.cu	/^	IndexArray size = grid_->my_size();$/;"	l
size	regular/cpu_kernel.cu	/^    int size = 0;$/;"	l
size	regular/data_type.h	/^	int size;$/;"	m	struct:element_t
size	regular/regular_runtime.cu	/^			int start,size;$/;"	l
size	regular/rog.cu	/^				unsigned short size = get_key_size(index);$/;"	l
size	regular/ros.cu	/^					unsigned short size = get_key_size(index);$/;"	l
size_	lib/buffer.h	/^	IndexArray size_;$/;"	m	class:Buffer
size_	lib/grid.h	/^	IndexArray size_;$/;"	m	class:Grid
size_to_tile	lib/data_util.cpp	/^	IndexArray size_to_tile = size;$/;"	l
sizes	regular/regular_runtime.cu	/^			int sizes[2]; \/\/size for each stream$/;"	l
sj	lib/array.h	/^    StringJoin sj;$/;"	l
sj	lib/array.h	/^  StringJoin sj;$/;"	l
sj	lib/array.h	/^  os << "{" << sj << "}";  $/;"	l
sj	lib/test/test_util.h	/^    ss << "data {" << sj << "}";$/;"	l
sj	lib/test/test_util.h	/^  StringJoin sj;$/;"	l
sort_edgelist	misc.c	/^sort_edgelist(int n_edges, int n_nodes, int (*el)[2])$/;"	f
sort_ord	misc.c	/^    int  *sort_ord, *from2, *from, *ptnr2;$/;"	l
sort_ord	misc.c	/^    int  *sort_ord, *from2, *ptnr2;$/;"	l
sortlist	misc.c	/^sortlist(int *list, int n) {$/;"	f
sp	moldyn.cu	/^   double ekin, ts, sp, sc, r, s;$/;"	l
speeds	irregular/partitioner.h	/^	double *speeds;$/;"	m	class:Partitioner
speeds_	irregular/irregular_runtime.h	/^	double *speeds_;$/;"	m	class:IrregularRuntime
speeds_	lib/stencil_runtime.h	/^	double *speeds_;$/;"	m	class:StencilRuntime
split	irregular/irregular_runtime.cu	/^void IrregularRuntime::split()$/;"	f	class:IrregularRuntime
split	lib/stencil_runtime.cu	/^void StencilRuntime::split()$/;"	f	class:StencilRuntime
splitter	regular/splitter.cpp	/^splitter::splitter($/;"	f	class:splitter
splitter	regular/splitter.h	/^class splitter$/;"	c
splitter_	regular/regular_runtime.h	/^	splitter *splitter_;$/;"	m	class:RegularRuntime
sq	moldyn.cu	/^  double vaverh, velocity, counter, sq;$/;"	l
sr	main.cpp	/^	StencilRuntime *sr = sc.CreateRuntime();$/;"	l
src	lib/buffer_cuda.cu	/^	BufferHost &src = *source;$/;"	l
src	lib/grid_cpu.cpp	/^	GridCPU *src = this;$/;"	l
src	lib/grid_cpu.cpp	/^	GridMPI *src = grid_global;$/;"	l
src	lib/grid_cuda.cu	/^		GridCuda *src = this;	$/;"	l
src	lib/grid_cuda.cu	/^		GridCuda *src = this;$/;"	l
src	lib/grid_cuda.cu	/^		GridMPI *src = grid_global;$/;"	l
src	lib/grid_mpi.cu	/^  	const void *src = buffer()->Get();$/;"	l
src	lib/grid_mpi.cu	/^                src, halo_.bw, my_size());$/;"	l
src	lib/grid_mpi.cu	/^                src, my_real_size(),$/;"	l
src_abs0	lib/buffer_cuda.cu	/^	int src_abs0, src_abs1, src_abs2;$/;"	l
src_abs1	lib/buffer_cuda.cu	/^	int src_abs0, src_abs1, src_abs2;$/;"	l
src_abs2	lib/buffer_cuda.cu	/^	int src_abs0, src_abs1, src_abs2;$/;"	l
src_addr	lib/buffer.cpp	/^	char *src_addr = (char *)src->Get();$/;"	l
src_addr	lib/buffer_cuda.cu	/^	char *src_addr = (char *)src.Get();$/;"	l
src_ptr	lib/data_util.cpp	/^      			const void *src_ptr;$/;"	l
src_ptr	lib/grid_util.cc	/^      const void *src_ptr;$/;"	l
src_start	lib/buffer.cpp	/^	IndexArray src_start;$/;"	l
src_start	lib/buffer_cuda.cu	/^	IndexArray src_start;$/;"	l
ss	lib/data_util.cpp	/^    		IndexArray ss = subgrid_size;$/;"	l
ss	lib/grid_util.cc	/^    IndexArray ss = subgrid_size;$/;"	l
ss	lib/test/test_util.h	/^  std::stringstream ss;$/;"	l
ss	lib/util.h	/^  std::ostringstream ss;$/;"	m	class:StringJoin
st	irregular/partitioner.cpp	/^                int st = start + j * num_points_per_part;$/;"	l
st	irregular/reorder.cpp	/^		int st = start + j * num_points_per_part; $/;"	l
start	input/gen.c	/^    int *nodes, *start, n_xyz[3], neiblk[27], xd,yd,zd, x,y,z;$/;"	l
start	irregular/cpu_kernel.cu	/^    	int start = task_index;$/;"	l
start	irregular/data_type.h	/^	int start;$/;"	m	struct:part
start	irregular/gpu_kernel.cu	/^        	int start = parts[j].start;$/;"	l
start	irregular/partitioner.cpp	/^		size_t start = node_id - device_num_nodes_sum_[device_id];	$/;"	l
start	lib/compute_cpu.cpp	/^	int start = tid * tiles_per_proc;$/;"	l
start	lib/data_util.cpp	/^	IndexArray start = halo.bw;		$/;"	l
start	misc.c	/^    int *nodes, *start, *nodes2, *start2;$/;"	l
start	moldyn.cu	/^    int *nodes, *start, n_xyz[3], neiblk[27], xd,yd,zd, x,y,z;$/;"	l
start	moldyn.cu	/^  int      start, end, how_often;$/;"	l
start	regular.h	/^	float *start = (float *)((char *)global_data + index);$/;"	l
start	regular/regular_runtime.cu	/^			int start,size;$/;"	l
start2	misc.c	/^    int *nodes, *start, *nodes2, *start2;$/;"	l
start_cpu	regular/regular_runtime.cu	/^void *RegularRuntime::start_cpu(void *arg)$/;"	f	class:RegularRuntime
start_gpu	regular/regular_runtime.cu	/^void *RegularRuntime::start_gpu(void *arg)$/;"	f	class:RegularRuntime
start_time	moldyn.cu	/^  int      tmp,procs,i,j,k,ii, start_time;$/;"	l
starts	regular/regular_runtime.cu	/^			int starts[2]; \/\/starting number for each stream$/;"	l
starts_	lib/stencil_runtime.h	/^	int *starts_;$/;"	m	class:StencilRuntime
stat	lib/time_util.cpp	/^    int stat;$/;"	l
stats	moldyn.h	/^int     stats    [MAX_STATS], $/;"	v
stats_avg	moldyn.h	/^        stats_avg[MAX_STATS];$/;"	v
stats_max	moldyn.h	/^        stats_max[MAX_STATS],$/;"	v
stats_min	moldyn.h	/^        stats_min[MAX_STATS], $/;"	v
std	irregular/cpu_kernel.cu	/^using namespace std;$/;"	v
std	km.cu	/^using namespace std;$/;"	v
std	lib/buffer_cuda.cu	/^using namespace std;$/;"	v
std	lib/grid_cuda.cu	/^using namespace std;$/;"	v
std	lib/grid_mpi.cu	/^using namespace std;$/;"	v
std	lib/stencil_runtime.cu	/^using namespace std;$/;"	v
std	regular/cpu_kernel.cu	/^using namespace std;$/;"	v
stencil	stencil.h	/^DEVICE void stencil(void *input, void *output, int *offset, int *size)$/;"	f	namespace:FGPU
stencil_width	lib/stencil_runtime.h	/^	int stencil_width(){return stencil_width_;}$/;"	f	class:StencilRuntime
stencil_width_	lib/stencil_creator.h	/^	int stencil_width_;$/;"	m	class:StencilCreator
stencil_width_	lib/stencil_runtime.h	/^	int stencil_width_;$/;"	m	class:StencilRuntime
str	lib/util.h	/^  std::string str() const {$/;"	f	class:StringJoin
streams_	regular/regular_runtime.h	/^	cudaStream_t **streams_;$/;"	m	class:RegularRuntime
stride	irregular/roc.cu	/^	int stride = 1;$/;"	l
stride	irregular/rog.cu	/^	int stride = 1;$/;"	l
stride	irregular/ros.cu	/^	int stride = 1;$/;"	l
stride	regular/roc.cu	/^    int stride = 1;$/;"	l
stride	regular/rog.cu	/^	int stride = 1;$/;"	l
stride	regular/ros.cu	/^	int stride = 1;\/\/NUM_BUCKETS\/2;$/;"	l
strm	lib/buffer_cuda.h	/^	cudaStream_t strm(){return strm_;}$/;"	f	class:BufferCUDAHost
strm_	lib/buffer_cuda.h	/^	cudaStream_t strm_;$/;"	m	class:BufferCUDAHost
subgrid_original	lib/data_util.cpp	/^  	intptr_t subgrid_original = (intptr_t) (is_copyin ? src : buf);$/;"	l
subgrid_original	lib/grid_util.cc	/^  intptr_t subgrid_original = (intptr_t) (is_copyin ? src : buf);$/;"	l
success	regular/gpu_kernel.cu	/^                bool success = FFGPU::map(((SO *)object_s + group_id), input, data_offset[i].offset, parameter, 1);$/;"	l
sum	moldyn.cu	/^  double sum;$/;"	l
swap	regular/rog.cu	/^__device__ void Reduction_Object_GPU::swap(unsigned long long int &a, unsigned long long int &b)$/;"	f	class:Reduction_Object_GPU
swap	regular/ros.cu	/^__device__ void Reduction_Object::swap(int &a, int &b)$/;"	f	class:Reduction_Object
swap_int	regular/rog.cu	/^__device__ void swap_int(unsigned int &a, unsigned int &b)$/;"	f
t	input/gen.c	/^   double t;$/;"	l
t	lib/grid_view.cpp	/^		int t = i;$/;"	l
t	misc.c	/^    int  i, j, k, t, n_pieces, root, root2, p, done, iter, real_i;$/;"	l
t1	misc.c	/^    double t1, t2;$/;"	l
t2	misc.c	/^    double t1, t2;$/;"	l
t_from	misc.c	/^     int *t_from, *t_ptnr, *ind;$/;"	l
t_from	misc.c	/^    int *t_ptnr, *t_from;$/;"	l
t_ptnr	misc.c	/^     int *t_from, *t_ptnr, *ind;$/;"	l
t_ptnr	misc.c	/^    int *t_ptnr, *t_from;$/;"	l
tag	irregular/partition_view.cpp	/^	int tag = 0;$/;"	l
tag	irregular/partition_view.cpp	/^	int tag = 1;$/;"	l
tag	irregular/partition_view.cpp	/^	int tag = 2;	$/;"	l
tag	lib/grid_view.cpp	/^	int tag = 0;$/;"	l
taken	misc.c	/^    int  *taken, *ind2;$/;"	l
taken	misc.c	/^    int *ind2, *taken, n_taken, *expanded, n_expanded, *from;$/;"	l
taken	misc.c	/^    int *ind2, *taken, n_taken, *expanded, n_expanded;$/;"	l
task_index	irregular/cpu_kernel.cu	/^    int task_index = 0;$/;"	l
task_index	irregular/gpu_kernel.cu	/^    __shared__ int task_index;      \/\/task index within each SM$/;"	l
task_index	regular/cpu_kernel.cu	/^    int task_index = 0;$/;"	l
task_index	regular/gpu_kernel.cu	/^    __shared__ int task_index;      \/\/task index within each SM$/;"	l
task_offset_	regular/regular_runtime.h	/^	int *task_offset_;$/;"	m	class:RegularRuntime
task_offset_d_	irregular/irregular_runtime.cu	/^			task_offset_d_[i],$/;"	l
task_offset_d_	irregular/irregular_runtime.h	/^	int **task_offset_d_;$/;"	m	class:IrregularRuntime
temp	moldyn.cu	/^ double ek, etot, temp, pres, rp, tscale ;$/;"	l
temp	regular.h	/^        float temp[5];$/;"	l
temp_lap	misc.c	/^    double temp_lap, temp_lap2, temp_lap3, tmp_time;$/;"	l
temp_lap	misc.c	/^    double temp_lap, temp_lap2, temp_lap3;$/;"	l
temp_lap	misc.c	/^    double temp_lap;$/;"	l
temp_lap2	misc.c	/^    double temp_lap, temp_lap2, temp_lap3, tmp_time;$/;"	l
temp_lap2	misc.c	/^    double temp_lap, temp_lap2, temp_lap3;$/;"	l
temp_lap3	misc.c	/^    double temp_lap, temp_lap2, temp_lap3, tmp_time;$/;"	l
temp_lap3	misc.c	/^    double temp_lap, temp_lap2, temp_lap3;$/;"	l
tid	irregular/cpu_args.h	/^	int tid;$/;"	m	struct:init_args
tid	irregular/cpu_args.h	/^	int tid;$/;"	m	struct:merge_args
tid	irregular/cpu_args.h	/^    int tid;$/;"	m	struct:cpu_args
tid	irregular/cpu_kernel.cu	/^    int tid = args->tid;$/;"	l
tid	irregular/gpu_kernel.cu	/^    const unsigned int tid = threadIdx.x;$/;"	l
tid	irregular/irregular_runtime.cu	/^	pthread_t tid;	$/;"	l
tid	irregular/irregular_runtime.cu	/^	pthread_t tid[CPU_THREADS];$/;"	l
tid	irregular/irregular_runtime.cu	/^        pthread_t tid[CPU_THREADS]; $/;"	l
tid	irregular/rog.cu	/^	const unsigned int tid = threadIdx.x;$/;"	l
tid	irregular/ros.cu	/^        const unsigned int tid = threadIdx.x;$/;"	l
tid	lib/buffer_cuda.cu	/^	int tid = threadIdx.x + blockIdx.x * blockDim.x;	$/;"	l
tid	lib/compute_cpu.cpp	/^	int tid = args->tid;$/;"	l
tid	lib/compute_cuda.cu	/^	const unsigned int tid = threadIdx.x;$/;"	l
tid	lib/cpu_util.h	/^	int tid;$/;"	m	struct:cargs
tid	lib/stencil_runtime.cu	/^		pthread_t tid[CPU_THREADS];$/;"	l
tid	lib/stencil_runtime.cu	/^	pthread_t tid[2];			$/;"	l
tid	regular/args.h	/^	int tid;$/;"	m	struct:cpu_args_reg
tid	regular/cpu_kernel.cu	/^    int tid = args->tid;$/;"	l
tid	regular/gpu_kernel.cu	/^    const unsigned int tid = threadIdx.x;$/;"	l
tid	regular/regular_runtime.cu	/^	pthread_t tid[CPU_THREADS];$/;"	l
tid	regular/rog.cu	/^	const unsigned int tid = threadIdx.x;$/;"	l
tid	regular/rog.cu	/^	unsigned int tid = threadIdx.x;$/;"	l
tid	regular/rog.cu	/^    const unsigned int tid = threadIdx.x;$/;"	l
tid	regular/ros.cu	/^	const unsigned int tid = threadIdx.x;$/;"	l
tid_cpu	regular/regular_runtime.cu	/^	pthread_t tid_cpu;	$/;"	l
tid_gpu	regular/regular_runtime.cu	/^	pthread_t *tid_gpu;$/;"	l
tids_	irregular/irregular_runtime.h	/^	pthread_t tids_[CPU_THREADS];$/;"	m	class:IrregularRuntime
tile	lib/compute_cpu.cpp	/^		struct Tile tile = tiles[i];	$/;"	l
tile	lib/compute_cpu.cpp	/^		struct Tile tile = tiles[tiles_per_proc * CPU_THREADS + tid];	$/;"	l
tile_grids	lib/stencil_runtime.cu	/^void StencilRuntime::tile_grids()$/;"	f	class:StencilRuntime
tile_size	lib/compute_cuda.cu	/^		int tile_size = linear_size;$/;"	l
tile_tmp	lib/data_util.cpp	/^					struct Tile tile_tmp = {offset_new, part_size};				$/;"	l
tile_tmp	lib/data_util.cpp	/^				struct Tile tile_tmp = {offset_new, part_size};				$/;"	l
tiles	lib/compute_cpu.cpp	/^	std::vector<struct Tile> tiles = *(args->tiles);$/;"	l
tiles	lib/cpu_util.h	/^	std::vector<struct Tile> *tiles;$/;"	m	struct:cargs
tiles_d	lib/stencil_runtime.cu	/^			tiles_d,$/;"	l
tiles_d	lib/stencil_runtime.cu	/^		Ltile *tiles_d;$/;"	l
tiles_per_proc	lib/compute_cpu.cpp	/^	int tiles_per_proc = floor((double)num_tiles\/CPU_THREADS); $/;"	l
tiling	lib/data_util.cpp	/^void tiling(int num_dims, IndexArray &size, IndexArray &start_offset, int tile_size, std::vector<struct Tile> &offset_vector)$/;"	f
tiling_border	lib/data_util.cpp	/^void tiling_border(int num_dims, IndexArray &size, IndexArray &real_size, Width2 halo, int tile_size, std::vector<struct Tile> &offset_vector)$/;"	f
timeStep	moldyn.cu	/^         timeStep,              \/*  length of each timestep   *\/$/;"	v
timeStep	moldyn.h	/^         timeStep,              \/*  length of each timestep   *\/$/;"	v
timeStepSq	moldyn.cu	/^         timeStepSq,            \/*  square of timestep        *\/$/;"	v
timeStepSq	moldyn.h	/^         timeStepSq,            \/*  square of timestep        *\/$/;"	v
timeStepSqHalf	moldyn.cu	/^         timeStepSqHalf,        \/*  1\/2 of square of timestep *\/$/;"	v
timeStepSqHalf	moldyn.h	/^         timeStepSqHalf,        \/*  1\/2 of square of timestep *\/$/;"	v
time_avg	moldyn.h	/^         time_avg[MAX_TIMERS], $/;"	v
time_max	moldyn.h	/^         time_max[MAX_TIMERS], $/;"	v
time_min	moldyn.h	/^         time_min[MAX_TIMERS];$/;"	v
time_st	moldyn.h	/^         time_st[MAX_TIMERS], $/;"	v
time_tot	moldyn.h	/^double  time_tot[MAX_TIMERS], $/;"	v
timer	metis.h	/^typedef double timer;$/;"	t
tmp	irregular/partition_view.cpp	/^	EDGE tmp;$/;"	l
tmp	irregular/partitioner.cpp	/^	T *tmp = (T *)malloc(sizeof(T)*num_dims);	$/;"	l
tmp	irregular/reorder.cpp	/^	T *tmp = (T *)malloc(sizeof(T)*num_dims);	$/;"	l
tmp	misc.c	/^    int *tmp;$/;"	l
tmp	misc.c	/^    int i, *count, *count2, *tmp, *tmp2, *p;$/;"	l
tmp	moldyn.cu	/^  int      tmp,procs,i,j,k,ii, start_time;$/;"	l
tmp	regular/regular_runtime.cu	/^			int tmp = 0;$/;"	l
tmp	regular/rog.cu	/^	unsigned int tmp =a;	$/;"	l
tmp	regular/rog.cu	/^	unsigned long long int tmp = a;$/;"	l
tmp	regular/ros.cu	/^	int tmp = a;$/;"	l
tmp2	misc.c	/^    int *idx, *tmp2;$/;"	l
tmp2	misc.c	/^    int i, *count, *count2, *tmp, *tmp2, *p;$/;"	l
tmp_pos	irregular/partitioner.cpp	/^	int tmp_pos = pos_map[i];$/;"	l
tmp_pos	irregular/reorder.cpp	/^	int tmp_pos = pos_map[i];$/;"	l
tmp_time	misc.c	/^    double  tmp_time,  tmp_time2;$/;"	l
tmp_time	misc.c	/^    double temp_lap, temp_lap2, temp_lap3, tmp_time;$/;"	l
tmp_time	misc.c	/^    double tmp_time, tmp_time2;$/;"	l
tmp_time	misc.c	/^    double tmp_time;$/;"	l
tmp_time	moldyn.cu	/^  double   init_time, prev_time = 0.0, tmp_time, update_time = 0.0;$/;"	l
tmp_time2	misc.c	/^    double  tmp_time,  tmp_time2;$/;"	l
tmp_time2	misc.c	/^    double tmp_time, tmp_time2;$/;"	l
tmp_time3	misc.c	/^    double  tmp_time3, tmp_time4=0.0;$/;"	l
tmp_time3	misc.c	/^    double tmp_time3, tmp_time4=0;$/;"	l
tmp_time4	misc.c	/^    double  tmp_time3, tmp_time4=0.0;$/;"	l
tmp_time4	misc.c	/^    double tmp_time3, tmp_time4=0;$/;"	l
tool	km.cu	/^    	double tool;$/;"	l
tot_dist	misc.c	/^    double dist, tot_dist, avg_dist;$/;"	l
tot_dist2	misc.c	/^    double tot_dist2, avg_dist2, begin_time;$/;"	l
total	irregular/partitioner.cpp	/^	int total = 0;$/;"	l
total	irregular/partitioner.cpp	/^        int total = end - start + 1;$/;"	l
total	irregular/reorder.cpp	/^	int total = end - start + 1;	$/;"	l
total	lib/buffer_cuda.cu	/^	int total = size0*size1*size2;$/;"	l
total	stencil.h	/^	float total = 0;$/;"	l
total_key_num_	regular/regular_runtime.h	/^	unsigned int total_key_num_;$/;"	m	class:RegularRuntime
total_key_size_	regular/regular_runtime.h	/^        unsigned int total_key_size_;$/;"	m	class:RegularRuntime
total_nodes	irregular/partition_view.cpp	/^	IRIndex total_nodes = my_num_nodes_ + remote_node_sum_[num_procs_-1] + (*remote_nodes[num_procs_-1]).size();$/;"	l
total_num_partitions	irregular/reorder.h	/^	int total_num_partitions;$/;"	m	class:Reorder
total_offsets	regular/regular_runtime.cu	/^	int total_offsets = dp_mpi_->num_offsets();$/;"	l
total_points	regular.h	/^        float total_points = num_points1+num_points2;$/;"	l
total_size	lib/compute_cpu.cpp	/^	IndexArray total_size = grid->my_real_size();$/;"	l
total_size	regular/regular_runtime.cu	/^	int total_size = dp_mpi_->input_size();$/;"	l
total_speed	irregular/partitioner.cpp	/^	double total_speed = 0;$/;"	l
total_speed	lib/stencil_runtime.cu	/^	double total_speed = 0;$/;"	l
total_threads	lib/buffer_cuda.cu	/^	int total_threads = blockDim.x * gridDim.x;$/;"	l
total_value_num_	regular/regular_runtime.h	/^        unsigned int total_value_num_;$/;"	m	class:RegularRuntime
total_value_size_	regular/regular_runtime.h	/^        unsigned int total_value_size_;$/;"	m	class:RegularRuntime
tp	misc.c	/^    int  *nodes, *degree, *cnt, *ind2, *nodes2, *tp;$/;"	l
ts	moldyn.cu	/^   double ekin, ts, sp, sc, r, s;$/;"	l
tscale	moldyn.cu	/^   double u1, u2, v1, v2, ujunk,tscale;$/;"	l
tscale	moldyn.cu	/^ double ek, etot, temp, pres, rp, tscale ;$/;"	l
tstep	moldyn.cu	/^  int      tstep, n_tstep, n_moles, n_inter;$/;"	l
tt	timer.c	/^   struct timeval tt;$/;"	l
tx	misc.c	/^     byte *ptr, *tx=NULL;$/;"	l
tx	misc.c	/^    byte *ptr, *tx = NULL;$/;"	l
type	metis.h	/^  int type;                     \/* The type of the representation used *\/$/;"	m	struct:PQueueType
u1	moldyn.cu	/^   double u1, u2, v1, v2, ujunk,tscale;$/;"	l
u2	moldyn.cu	/^   double u1, u2, v1, v2, ujunk,tscale;$/;"	l
ub	misc.c	/^    int i, lb, ub, ep0, ep1, localL, localR;$/;"	l
ub	misc.c	/^    int i, p, lb, ub, pt, bp, ip, jp, localI, localP;$/;"	l
ujunk	moldyn.cu	/^   double u1, u2, v1, v2, ujunk,tscale;$/;"	l
unit_size	lib/compute_cpu.cpp	/^	int unit_size = runtime->unit_size();$/;"	l
unit_size	lib/grid.h	/^	int unit_size() const$/;"	f	class:Grid
unit_size	lib/stencil_runtime.h	/^	int unit_size(){return unit_size_;}$/;"	f	class:StencilRuntime
unit_size_	irregular/reduction_array.h	/^	int unit_size_;$/;"	m	class:reduction_array
unit_size_	lib/grid.h	/^	int unit_size_;$/;"	m	class:Grid
unit_size_	lib/stencil_runtime.h	/^	int unit_size_;$/;"	m	class:StencilRuntime
unit_sz	misc.c	/^   int n_nodes, n_edges, (*el)[2], n, unit_sz, i, apply;$/;"	l
unit_sz	misc.c	/^   int n_nodes, n_edges, *partners, *from, n, unit_sz, i, apply;$/;"	l
update_freq	moldyn.cu	/^  int      update_freq = 1, naive = 0;$/;"	l
update_time	moldyn.cu	/^  double   init_time, prev_time = 0.0, tmp_time, update_time = 0.0;$/;"	l
v	input/gen.c	/^double  v [NUM_PARTICLES][3];  \/* x,y,z coordinates of each molecule *\/$/;"	v
v	lib/array.h	/^    size_t v = 1;$/;"	l
v	main.cpp	/^  float v = N * N * N* my_rank;$/;"	l
v	main2.cpp	/^  float v = N * N * N* my_rank;$/;"	l
v	moldyn.cu	/^double  v [NUM_PARTICLES+4][3];  \/* x,y,z coordinates of each molecule *\/$/;"	v
v	moldyn.cu	/^double  v [NUM_PARTICLES][3];  \/* x,y,z coordinates of each molecule *\/$/;"	v
v	regular/roc.cu	/^                    int v = omalloc(value_size);$/;"	l
v	regular/rog.cu	/^				int v = omalloc(value_size);$/;"	l
v	regular/ros.cu	/^					short v = omalloc(value_size);$/;"	l
v1	moldyn.cu	/^   double u1, u2, v1, v2, ujunk,tscale;$/;"	l
v2	moldyn.cu	/^   double u1, u2, v1, v2, ujunk,tscale;$/;"	l
val	metis.h	/^  idxtype val;$/;"	m	struct:KeyValueType
val_index	regular/data_type.h	/^    unsigned int *val_index;$/;"	m	struct:output
value	irregular/parameters.h	/^struct value$/;"	s
value	regular.h	/^        float value[5];$/;"	l
value	regular/gpu_kernel.cu	/^			void *value = srcobject->get_value_address(index);$/;"	l
value	regular/roc.cu	/^                        FFCPU::reduce(get_value_address(index), get_value_size(index), value, value_size);          $/;"	l
value	regular/roc.cu	/^            void *value = object->get_value_address(i); $/;"	l
value	regular/rog.cu	/^					FFGPU::reduce(get_value_address(index), get_value_size(index), value, value_size);$/;"	l
value	regular/rog.cu	/^            void *value = object->get_value_address(i);$/;"	l
value	regular/ros.cu	/^						FFGPU::reduce(get_value_address(index), get_value_size(index), value, value_size);$/;"	l
value	regular/ros.cu	/^			void *value = object->get_value_address(i);$/;"	l
value_addr1	regular/rog.cu	/^		void *value_addr1 = get_value_address(bucket_index1);$/;"	l
value_addr1	regular/ros.cu	/^		void *value_addr1 = get_value_address(bucket_index1);$/;"	l
value_addr2	regular/rog.cu	/^		void *value_addr2 = get_value_address(bucket_index2);$/;"	l
value_addr2	regular/ros.cu	/^		void *value_addr2 = get_value_address(bucket_index2);$/;"	l
value_address	regular/roc.cu	/^                    void * value_address = get_address(v);$/;"	l
value_data_start	regular/rog.cu	/^				void *value_data_start = oget_address(v); $/;"	l
value_data_start	regular/ros.cu	/^					void *value_data_start = oget_address(v); $/;"	l
value_index	regular/roc.cu	/^    unsigned value_index = buckets[index].value_index;$/;"	l
value_index	regular/roc.h	/^    int value_index;$/;"	m	struct:intl
value_index	regular/rog.cu	/^	unsigned int value_index = ((unsigned int *)&buckets[bucket_index])[1]; $/;"	l
value_index	regular/ros.cu	/^	unsigned short value_index = ((unsigned short *)&buckets[bucket_index])[1]; $/;"	l
value_size	regular/data_type.h	/^    unsigned int value_size;$/;"	m	struct:output
value_size	regular/gpu_kernel.cu	/^			int value_size = srcobject->get_value_size(index);$/;"	l
value_size	regular/roc.cu	/^                        FFCPU::reduce(get_value_address(index), get_value_size(index), value, value_size);          $/;"	l
value_size	regular/roc.cu	/^            unsigned value_size = object->get_value_size(i);$/;"	l
value_size	regular/rog.cu	/^					FFGPU::reduce(get_value_address(index), get_value_size(index), value, value_size);$/;"	l
value_size	regular/rog.cu	/^            unsigned value_size = object->get_value_size(i);$/;"	l
value_size	regular/ros.cu	/^						FFGPU::reduce(get_value_address(index), get_value_size(index), value, value_size);$/;"	l
value_size1	regular/rog.cu	/^		unsigned short value_size1 = get_value_size(bucket_index1);$/;"	l
value_size1	regular/ros.cu	/^		unsigned short value_size1 = get_value_size(bucket_index1);$/;"	l
value_size2	regular/rog.cu	/^		unsigned short value_size2 = get_value_size(bucket_index2);$/;"	l
value_size2	regular/ros.cu	/^		unsigned short value_size2 = get_value_size(bucket_index2);$/;"	l
value_size_address	regular/ros.cu	/^					char *value_size_address = key_size_address + 1;$/;"	l
value_size_per_bucket	regular/roc.h	/^        unsigned int value_size_per_bucket[NUM_BUCKETS_G];$/;"	m	struct:roc
value_size_per_bucket	regular/rog.h	/^		unsigned int value_size_per_bucket[NUM_BUCKETS_G];$/;"	m	struct:Reduction_Object_GPU
values	irregular/roc.h	/^	VALUE values[NUM_BUCKETS_G];$/;"	m	struct:Reduction_Object_C
values	irregular/rog.h	/^	VALUE values[NUM_BUCKETS_G];$/;"	m	struct:Reduction_Object_G
values	irregular/ros.h	/^		VALUE values[NUM_BUCKETS_S];$/;"	m	struct:Reduction_Object_S
vaver	moldyn.cu	/^         vaver;                 \/*                            *\/$/;"	v
vaver	moldyn.h	/^         vaver,                 \/*                            *\/$/;"	v
vaverh	moldyn.cu	/^  double vaverh, velocity, counter, sq;$/;"	l
vedegreedef	metis.h	/^struct vedegreedef {$/;"	s
vedegrees	metis.h	/^  VEDegreeType *vedegrees;$/;"	m	struct:workspacedef
vel	moldyn.cu	/^  double   count, vel ;$/;"	l
velocity	moldyn.cu	/^  double vaverh, velocity, counter, sq;$/;"	l
vh	moldyn.cu	/^double  vh [NUM_PARTICLES][3];   \/* partial x,y,z velocity of molecule *\/$/;"	v
vhx	moldyn.cu	104;"	d	file:
vhx	moldyn.h	/^double  vhx[NUM_PARTICLES],   \/* partial x,y,z velocity of molecule *\/$/;"	v
vhy	moldyn.cu	105;"	d	file:
vhy	moldyn.h	/^        vhy[NUM_PARTICLES],   $/;"	v
vhz	moldyn.cu	106;"	d	file:
vhz	moldyn.h	/^        vhz[NUM_PARTICLES];   $/;"	v
vir	moldyn.cu	/^         vir;                   \/*  The virial  energy        *\/$/;"	v
vir	moldyn.h	/^         vir;                   \/*  The virial  energy        *\/$/;"	v
vpwgtdef	metis.h	/^struct vpwgtdef {$/;"	s
vrinfo	metis.h	/^  VRInfoType *vrinfo;$/;"	m	struct:graphdef
vrinfodef	metis.h	/^struct vrinfodef {$/;"	s
vsize	metis.h	/^  idxtype *vsize;		\/* Vertex sizes for min-volume formulation *\/$/;"	m	struct:graphdef
vwgt	metis.h	/^  idxtype *vwgt;		\/* Vertex weights *\/$/;"	m	struct:graphdef
w	main2.cpp	/^	Width2 w = {halo, halo};$/;"	l
wgtflag	misc.c	/^    int numflag = 0, wgtflag = 0, edgecut;$/;"	l
where	metis.h	/^  idxtype *where, *pwgts;$/;"	m	struct:graphdef
width	lib/compute_cpu.cpp	/^	int width = runtime->stencil_width();	$/;"	l
workspacedef	metis.h	/^struct workspacedef {$/;"	s
wspace	metis.h	/^  WorkSpaceType wspace;		\/* Work Space Informations *\/$/;"	m	struct:controldef
x	input/gen.c	/^    int *nodes, *start, n_xyz[3], neiblk[27], xd,yd,zd, x,y,z;$/;"	l
x	input/gen.c	21;"	d	file:
x	irregular/parameters.h	/^	float x;$/;"	m	struct:value
x	irregular/partitioner.cpp	/^	T x = *end;$/;"	l
x	irregular/partitioner.cpp	/^	int x, y;$/;"	l
x	irregular/reorder.cpp	/^	T x = *end;$/;"	l
x	irregular/reorder.cpp	/^	int x, y;$/;"	l
x	moldyn.cu	/^    int *nodes, *start, n_xyz[3], neiblk[27], xd,yd,zd, x,y,z;$/;"	l
x	moldyn.cu	108;"	d	file:
x	moldyn.h	/^double  x[NUM_PARTICLES],   \/* x,y,z coordinates of each molecule *\/$/;"	v
x1	input/gen.c	/^    int x1[3], y1[3], z1[3];$/;"	l
x1	moldyn.cu	/^    int x1[3], y1[3], z1[3];$/;"	l
xadj	metis.h	/^  idxtype *xadj;		\/* Pointers to the locally stored vertices *\/$/;"	m	struct:graphdef
xd	input/gen.c	/^    int *nodes, *start, n_xyz[3], neiblk[27], xd,yd,zd, x,y,z;$/;"	l
xd	moldyn.cu	/^    int *nodes, *start, n_xyz[3], neiblk[27], xd,yd,zd, x,y,z;$/;"	l
xx	input/gen.c	/^    double sideHalf, cutoffSquare, rd, xx, yy, zz;$/;"	l
xx	input/gen.c	/^  double cutoffSquare, xx, yy, zz, rd;$/;"	l
xx	irregular.h	/^		double xx,yy,zz;$/;"	l
xx	misc.c	/^    double *xx, *yy;$/;"	l
xx	moldyn.cu	/^	   double xx, yy, zz;$/;"	l
xx	moldyn.cu	/^    double sideHalf, cutoffSquare, rd, xx, yy, zz;$/;"	l
xyz2n	input/gen.c	270;"	d	file:
xyz2n	moldyn.cu	793;"	d	file:
y	input/gen.c	/^    int *nodes, *start, n_xyz[3], neiblk[27], xd,yd,zd, x,y,z;$/;"	l
y	input/gen.c	22;"	d	file:
y	irregular/parameters.h	/^	float y;$/;"	m	struct:value
y	irregular/partitioner.cpp	/^	int x, y;$/;"	l
y	irregular/reorder.cpp	/^	int x, y;$/;"	l
y	moldyn.cu	/^    int *nodes, *start, n_xyz[3], neiblk[27], xd,yd,zd, x,y,z;$/;"	l
y	moldyn.cu	109;"	d	file:
y	moldyn.h	/^        y[NUM_PARTICLES],  $/;"	v
y1	input/gen.c	/^    int x1[3], y1[3], z1[3];$/;"	l
y1	moldyn.cu	/^    int x1[3], y1[3], z1[3];$/;"	l
yd	input/gen.c	/^    int *nodes, *start, n_xyz[3], neiblk[27], xd,yd,zd, x,y,z;$/;"	l
yd	moldyn.cu	/^    int *nodes, *start, n_xyz[3], neiblk[27], xd,yd,zd, x,y,z;$/;"	l
yy	input/gen.c	/^    double sideHalf, cutoffSquare, rd, xx, yy, zz;$/;"	l
yy	input/gen.c	/^  double cutoffSquare, xx, yy, zz, rd;$/;"	l
yy	irregular.h	/^		double xx,yy,zz;$/;"	l
yy	misc.c	/^    double *xx, *yy;$/;"	l
yy	moldyn.cu	/^	   double xx, yy, zz;$/;"	l
yy	moldyn.cu	/^    double sideHalf, cutoffSquare, rd, xx, yy, zz;$/;"	l
z	input/gen.c	/^    int *nodes, *start, n_xyz[3], neiblk[27], xd,yd,zd, x,y,z;$/;"	l
z	input/gen.c	23;"	d	file:
z	irregular/parameters.h	/^	float z;$/;"	m	struct:value
z	moldyn.cu	/^    int *nodes, *start, n_xyz[3], neiblk[27], xd,yd,zd, x,y,z;$/;"	l
z	moldyn.cu	110;"	d	file:
z	moldyn.h	/^        z[NUM_PARTICLES]; $/;"	v
z1	input/gen.c	/^    int x1[3], y1[3], z1[3];$/;"	l
z1	moldyn.cu	/^    int x1[3], y1[3], z1[3];$/;"	l
zd	input/gen.c	/^    int *nodes, *start, n_xyz[3], neiblk[27], xd,yd,zd, x,y,z;$/;"	l
zd	moldyn.cu	/^    int *nodes, *start, n_xyz[3], neiblk[27], xd,yd,zd, x,y,z;$/;"	l
zt	Session.vim	/^normal! zt$/;"	m
zt	input/Session.vim	/^normal! zt$/;"	m
zt	lib/Session.vim	/^normal! zt$/;"	m
zz	input/gen.c	/^    double sideHalf, cutoffSquare, rd, xx, yy, zz;$/;"	l
zz	input/gen.c	/^  double cutoffSquare, xx, yy, zz, rd;$/;"	l
zz	irregular.h	/^		double xx,yy,zz;$/;"	l
zz	moldyn.cu	/^	   double xx, yy, zz;$/;"	l
zz	moldyn.cu	/^    double sideHalf, cutoffSquare, rd, xx, yy, zz;$/;"	l
~Buffer	lib/buffer.cpp	/^Buffer::~Buffer()$/;"	f	class:Buffer
~BufferCUDADev	lib/buffer_cuda.cu	/^BufferCUDADev::~BufferCUDADev() $/;"	f	class:BufferCUDADev
~BufferCUDAHost	lib/buffer_cuda.cu	/^BufferCUDAHost::~BufferCUDAHost() $/;"	f	class:BufferCUDAHost
~BufferHost	lib/buffer.cpp	/^BufferHost::~BufferHost(){Free();}$/;"	f	class:BufferHost
~Grid	lib/grid.cpp	/^Grid::~Grid()$/;"	f	class:Grid
~GridMPI	lib/grid_mpi.cu	/^GridMPI::~GridMPI()$/;"	f	class:GridMPI
~IrregularRuntime	irregular/irregular_runtime.cu	/^IrregularRuntime::~IrregularRuntime()$/;"	f	class:IrregularRuntime
~partition	irregular/partition.h	/^	~partition()$/;"	f	class:partition
~partition_cpu	irregular/partition_cpu.h	/^		~partition_cpu()$/;"	f	class:partition_cpu
~partition_cuda	irregular/partition_cuda.cu	/^partition_cuda::~partition_cuda()$/;"	f	class:partition_cuda
